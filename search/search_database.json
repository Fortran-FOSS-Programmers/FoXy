var tipuesearch = {"pages":[{"title":" FoXy ","text":"FoXy FoXy FoXy, Fortran XML parser for poor people A KISS pure Fortran Library for parsing XML files FoXy is a pure Fortran (KISS) library for modern Fortran projects; FoXy is Fortran 2008+ standard compliant; FoXy is OOP designed; FoXy is a Free, Open Source Project. Compiler Support What is FoXy? | Aims | Status | Documentation | Copyrights What is FoXy? Modern Fortran standards (2003+) have introduced better support for strings manipulations. Exploiting such new Fortran capabilities, FoXy is aimed to provide an easy to use module library to parse and emit XML files and or tags. Aims Other programming languages have many libraries for XML parsing, Fortran has less options, but some there are: xml-fortran of Arjen Markus; xml-f90 of Alberto Garcia; fox of Andrew Walker that is an improved fork of xml-f90 of Alberto Garcia; tixi from DLR Simulation and Software Technology (C-binding). All of the above are great codes, but lack in some points that we would like to have: actively maintained; designed for modern Fortran: OOP designed; exploiting new features of Fortran (e.g. deferred length allocatable characters); recreate a pure Fortran representation of the XML data (e.g. tree structure exploiting); parallel architectures supported (threads/processes safety ensured); extensively tested (strong unit-test regression); comprehensively documented; pure Fortran: no wrapper; no bindings, no ISO_C_BINDING ; be FOSS. In some sense or other, the afore-mentioned Fortran libraries miss somethings. Go to Top Status Features [ ] Input: [ ] parse input file/string: [x] create linearized DOM (nested and repeated tags supported) [ ] lazy inquire tag into DOM; [x] Output: [x] write tag ( atomically ) on file/string; [x] Input/Output: [x] create tag structure: [x] start tag with name and attributes; [x] self closing tag; [x] nested tag; [x] tag content; [x] end tag; [x] tag DOM hierarchy (tag ID, parent ID, children IDs, level); [x] tag indent; [x] add tag to DOM; [x] delete tag from DOM; Doing lazy inquire tag into DOM. Todo profile the parser: almost surely there are performance penalties; Go to Top Documentation Besides this README file the FoXy documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Copyrights FoXy is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FoXy is welcome, feel free to select the license that best matches your soul! Go to Top Developer Info Fortran-FOSS-Programmers Group","tags":"home","url":"index.html"},{"title":"xml_tag – FoXy ","text":"type, public :: xml_tag XML tag class. A valid XML tag must have the following syntax for a tag without a content (with only attributes): <Tag_Name att# 1_Name= \"att#1_val\" att# 2_Name= \"att#2_val\" ... att# Nt_Name= \"att#Nt_val\" /> while a tag with a content must have the following syntax: <Tag_Name att# 1_Name= \"att#1_val\" att# 2_Name= \"att#2_val\" ... att# Nt_Name= \"att#Nt_val\" > Tag_Content </Tag_Name> It is worth noting that the syntax is case sensitive and that the attributes are optional. Each attribute name must be\n followed by '=\"' without any additional white spaces and its value must be termined by '\"'. Each attribute is separated\n by one or more white spaces. Inherits type~~xml_tag~~InheritsGraph type~xml_tag xml_tag string string type~xml_tag->string tag_name, tag_content, attribute Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~xml_tag~~InheritedByGraph type~xml_tag xml_tag type~xml_file xml_file type~xml_file->type~xml_tag tag Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type(string), private :: tag_name Tag name. type(string), private :: tag_content Tag content. integer(kind=I4P), private :: pos (3) = [0_I4P, 0_I4P, 0_I4P] Characters position (in source) indexes (start, content, end). type(string), private, allocatable :: attribute (:,:) Attributes names/values pairs, [1:2, 1:]. integer(kind=I4P), private :: attributes_number = 0_I4P Number of defined attributes. integer(kind=I4P), private :: indent = 0_I4P Number of indent-white-spaces. logical, private :: is_self_closing = .false. Self closing tag flag. integer(kind=I4P), private :: level = 0_I4P Tag hierarchy level. integer(kind=I4P), private :: id = 0_I4P Uniq tag ID. integer(kind=I4P), private :: parent_id = 0_I4P Uniq ID of parent tag. integer(kind=I4P), public :: children_number = 0_I4P Number of children tags. integer(kind=I4P), public, allocatable :: child_id (:) Uniq ID of children tags. Constructor public        interface xml_tag Overload xml_tag with creator procedures. private pure function create_tag_flat (name, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, content, indent, is_content_indented, is_self_closing, id, level, parent_id, attributes_stream_alloc, content_alloc) result(tag) Return an instance of xml tag. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Tag name. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list as single stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. character(len=*), intent(in), optional :: content Tag value. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate content indentation. logical, intent(in), optional :: is_self_closing The tag is self closing. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Return Value type( xml_tag ) XML tag. private pure function create_tag_nested (name, content, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, indent, is_content_indented, id, level, parent_id, attributes_stream_alloc, content_alloc) result(tag) Return an instance of xml tag with value being a nested tag. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Tag name. type( xml_tag ), intent(in) :: content Tag value as nested tag.. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list as single stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate value indentation. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Return Value type( xml_tag ) XML tag. Finalization Procedures final :: finalize Free dynamic memory when finalizing. private elemental subroutine finalize (tag) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( xml_tag ), intent(inout) :: tag XML tag. Type-Bound Procedures generic, public :: add_attributes => add_single_attribute , add_multiple_attributes , add_stream_attributes Add attributes name/value pairs. private pure subroutine add_single_attribute (self, attribute, sanitize_value) Add one attribute name/value pair. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attribute (1:) Attribute name/value pair [1:2]. logical, intent(in), optional :: sanitize_value Sanitize attribute value. private pure subroutine add_multiple_attributes (self, attributes, sanitize_values) Add list of attributes name/value pairs. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attributes (1:,1:) Attribute name/value pair list [1:2,1:]. logical, intent(in), optional :: sanitize_values Sanitize attribute values. private pure subroutine add_stream_attributes (self, attributes_stream, sanitize_values) Add list of attributes name/value pairs passed as stream. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attributes_stream Attribute name/value pair list passed as stream. logical, intent(in), optional :: sanitize_values Sanitize attribute values. procedure, public, pass(self) :: add_child_id Add child ID to children IDs list. private pure subroutine add_child_id (self, child_id) Add child ID to children IDs list. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. integer(kind=I4P), intent(in) :: child_id Child ID. procedure, public, pass(self) :: attributes Return attributes name/value pairs as string. private pure function attributes (self) result(att_) Return attributes name/value pairs as string. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value character(len=:), allocatable The attributes string. generic, public :: delete_attributes => delete_single_attribute , delete_multiple_attributes Delete attributes name/value pairs. private pure subroutine delete_single_attribute (self, name) Delete one attribute name/value pair. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: name Attribute name. private pure subroutine delete_multiple_attributes (self, name) Delete list of attributes name/value pairs. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: name (1:) Attributes names. procedure, public, pass(self) :: delete_content Delete tag conent. private pure subroutine delete_content (self) Delete tag content. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. procedure, public, pass(self) :: end_tag Return </tag_name> end tag. private pure function end_tag (self, is_indented) result(tag_) Return </tag_name> end tag. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Activate content indentation. Return Value character(len=:), allocatable The end tag string. procedure, public, pass(self) :: free Free (reset) tag. private elemental subroutine free (self) Free (reset) tag. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. procedure, public, pass(self) :: get_content Return tag content. private pure subroutine get_content (self, name, content) Return tag content of self (or its nested tags) if named name . Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. character(len=*), intent(in) :: name Searched tag name. character(len=:), intent(out), allocatable :: content Tag content. procedure, public, pass(self) :: is_attribute_present Return .true. it the queried attribute name is defined. private pure function is_attribute_present (self, name) result(is_present) Return .true. it the queried attribute name is defined, .false. otherwise. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. character(len=*), intent(in) :: name Attribute name. Return Value logical Inquire result. procedure, public, pass(self) :: is_parsed Check is tag is correctly parsed, i.e. its tag_name is allocated. private elemental function is_parsed (self) Check is tag is correctly parsed, i.e. its tag_name is allocated. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value logical Result of check. procedure, public, pass(self) :: name Return tag name. private pure function name (self) Return tag name. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value character(len=:), allocatable XML tag name. procedure, public, pass(self) :: parse Parse the tag contained into a source string. private elemental subroutine parse (self, source, tstart, tend) Parse the tag contained into a source string. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the string. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the string. procedure, public, pass(self) :: parse_tag_name Parse the tag name contained into a string. private elemental subroutine parse_tag_name (self, source, tstart, tend) Parse the tag name contained into a string. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the source. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the source. procedure, public, pass(self) :: self_closing_tag Return <tag_name.../> self closing tag. private pure function self_closing_tag (self, is_indented) result(tag_) Return <tag_name.../> self closing tag. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Flag to check if tag is indented. Return Value character(len=:), allocatable The self closing tag string. procedure, public, pass(self) :: set Set tag data. private pure subroutine set (self, name, attribute, attributes, attributes_stream, sanitize_attributes_value, content, pos, indent, is_content_indented, is_self_closing, id, level, parent_id, attributes_stream_alloc, content_alloc) Set tag data. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in), optional :: name Tag name. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list of name/value pairs as stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. character(len=*), intent(in), optional :: content Tag value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate value indentation. logical, intent(in), optional :: is_self_closing The tag is self closing. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. procedure, public, pass(self) :: start_tag Return <tag_name...> start tag. private pure function start_tag (self, is_indented) result(tag_) Return <tag_name...> start tag. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Flag to check if tag is indented. Return Value character(len=:), allocatable The start tag string. procedure, public, pass(self) :: stringify Convert the whole tag into a string. private pure function stringify (self, is_indented, is_content_indented, only_start, only_content, only_end, linearize) result(stringed) Convert the whole tag into a string. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Activate content indentation. logical, intent(in), optional :: is_content_indented Activate content indentation. logical, intent(in), optional :: only_start Write only start tag. logical, intent(in), optional :: only_content Write only content. logical, intent(in), optional :: only_end Write only end tag. logical, intent(in), optional :: linearize Return a \"linearized\" string of tags without the XML hieararchy. Return Value character(len=:), allocatable Output string containing the whole tag. procedure, public, pass(self) :: write => write_tag Write tag to unit file. private  subroutine write_tag (self, unit, is_indented, is_content_indented, form, end_record, only_start, only_content, only_end, iostat, iomsg) Write tag to unit file. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. integer(kind=I4P), intent(in) :: unit File unit. logical, intent(in), optional :: is_indented Activate content indentation. logical, intent(in), optional :: is_content_indented Activate content indentation. character(len=*), intent(in), optional :: form Format. character(len=*), intent(in), optional :: end_record Ending record. logical, intent(in), optional :: only_start Write only start tag. logical, intent(in), optional :: only_content Write only content. logical, intent(in), optional :: only_end Write only end tag. integer(kind=I4P), intent(out), optional :: iostat IO status. character(len=*), intent(out), optional :: iomsg IO message. generic, public :: assignment(=) => assign_tag Assignment operator overloading. private elemental subroutine assign_tag (lhs, rhs) Assignment between two tags. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: lhs Left hand side. type( xml_tag ), intent(in) :: rhs Right hand side. procedure, private, pass(self) :: add_single_attribute Add one attribute name/value pair. private pure subroutine add_single_attribute (self, attribute, sanitize_value) Add one attribute name/value pair. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attribute (1:) Attribute name/value pair [1:2]. logical, intent(in), optional :: sanitize_value Sanitize attribute value. procedure, private, pass(self) :: add_multiple_attributes Add list of attributes name/value pairs. private pure subroutine add_multiple_attributes (self, attributes, sanitize_values) Add list of attributes name/value pairs. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attributes (1:,1:) Attribute name/value pair list [1:2,1:]. logical, intent(in), optional :: sanitize_values Sanitize attribute values. procedure, private, pass(self) :: add_stream_attributes Add list of attributes name/value pairs passed as stream. private pure subroutine add_stream_attributes (self, attributes_stream, sanitize_values) Add list of attributes name/value pairs passed as stream. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attributes_stream Attribute name/value pair list passed as stream. logical, intent(in), optional :: sanitize_values Sanitize attribute values. procedure, private, pass(self) :: alloc_attributes Allocate (prepare for filling) dynamic memory of attributes. private elemental subroutine alloc_attributes (self, Na) Allocate (prepare for filling) dynamic memory of attributes. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. integer(kind=I4P), intent(in) :: Na Number of attributes. procedure, private, pass(self) :: delete_single_attribute Delete one attribute name/value pair. private pure subroutine delete_single_attribute (self, name) Delete one attribute name/value pair. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: name Attribute name. procedure, private, pass(self) :: delete_multiple_attributes Delete list of attributes name/value pairs. private pure subroutine delete_multiple_attributes (self, name) Delete list of attributes name/value pairs. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: name (1:) Attributes names. procedure, private, pass(self) :: get Get the tag value and attributes from source. private elemental subroutine get (self, source) Get the tag content and attributes from source after tag_name and attributes names have been set. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. procedure, private, pass(self) :: get_value Get the tag value from source after tag_name has been set. private elemental subroutine get_value (self, source) Get the tag value from source after tag_name has been set. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. procedure, private, pass(self) :: get_attributes Get the attributes values from source. private elemental subroutine get_attributes (self, source) Get the attributes values from source after tag_name and attributes names have been set. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. procedure, private, pass(self) :: parse_attributes_names Parse the tag attributes names contained into a string. private elemental subroutine parse_attributes_names (self, source) Parse the tag attributes names contained into a string. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. procedure, private, pass(self) :: search Search tag named tag_name into a string. private elemental subroutine search (self, tag_name, source, tstart, tend) Search tag named tag_name into a string and, in case it is found, store into self. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: tag_name Searched tag name. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the source. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the source. procedure, private, pass(lhs) :: assign_tag Assignment between two tags. private elemental subroutine assign_tag (lhs, rhs) Assignment between two tags. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: lhs Left hand side. type( xml_tag ), intent(in) :: rhs Right hand side. Source Code type :: xml_tag !< XML tag class. !< !< A valid XML tag must have the following syntax for a tag without a content (with only attributes): !<```xml !<   <Tag_Name att#1_Name=\"att#1_val\" att#2_Name=\"att#2_val\"... att#Nt_Name=\"att#Nt_val\"/> !<``` !< while a tag with a content must have the following syntax: !<```xml !<   <Tag_Name att#1_Name=\"att#1_val\" att#2_Name=\"att#2_val\"... att#Nt_Name=\"att#Nt_val\">Tag_Content</Tag_Name> !<``` !< !< It is worth noting that the syntax is case sensitive and that the attributes are optional. Each attribute name must be !< followed by '=\"' without any additional white spaces and its value must be termined by '\"'. Each attribute is separated !< by one or more white spaces. private type ( string ) :: tag_name !< Tag name. type ( string ) :: tag_content !< Tag content. integer ( I4P ) :: pos ( 3 ) = [ 0_I4P , 0_I4P , 0_I4P ] !< Characters position (in source) indexes (start, content, end). type ( string ), allocatable :: attribute (:,:) !< Attributes names/values pairs, [1:2, 1:]. integer ( I4P ) :: attributes_number = 0_I4P !< Number of defined attributes. integer ( I4P ) :: indent = 0_I4P !< Number of indent-white-spaces. logical :: is_self_closing = . false . !< Self closing tag flag. integer ( I4P ) :: level = 0_I4P !< Tag hierarchy level. integer ( I4P ) :: id = 0_I4P !< Uniq tag ID. integer ( I4P ) :: parent_id = 0_I4P !< Uniq ID of parent tag. integer ( I4P ), public :: children_number = 0_I4P !< Number of children tags. integer ( I4P ), public , allocatable :: child_id (:) !< Uniq ID of children tags. contains ! public methods generic :: add_attributes => & add_single_attribute , & add_multiple_attributes , & add_stream_attributes !< Add attributes name/value pairs. procedure , pass ( self ) :: add_child_id !< Add child ID to children IDs list. procedure , pass ( self ) :: attributes !< Return attributes name/value pairs as string. generic :: delete_attributes => & delete_single_attribute , & delete_multiple_attributes !< Delete attributes name/value pairs. procedure , pass ( self ) :: delete_content !< Delete tag conent. procedure , pass ( self ) :: end_tag !< Return `</tag_name>` end tag. procedure , pass ( self ) :: free !< Free (reset) tag. procedure , pass ( self ) :: get_content !< Return tag content. procedure , pass ( self ) :: is_attribute_present !< Return .true. it the queried attribute name is defined. procedure , pass ( self ) :: is_parsed !< Check is tag is correctly parsed, i.e. its *tag_name* is allocated. procedure , pass ( self ) :: name !< Return tag name. procedure , pass ( self ) :: parse !< Parse the tag contained into a source string. procedure , pass ( self ) :: parse_tag_name !< Parse the tag name contained into a string. procedure , pass ( self ) :: self_closing_tag !< Return `<tag_name.../>` self closing tag. procedure , pass ( self ) :: set !< Set tag data. procedure , pass ( self ) :: start_tag !< Return `<tag_name...>` start tag. procedure , pass ( self ) :: stringify !< Convert the whole tag into a string. procedure , pass ( self ) :: write => write_tag !< Write tag to unit file. generic :: assignment ( = ) => assign_tag !< Assignment operator overloading. ! private methods procedure , pass ( self ), private :: add_single_attribute !< Add one attribute name/value pair. procedure , pass ( self ), private :: add_multiple_attributes !< Add list of attributes name/value pairs. procedure , pass ( self ), private :: add_stream_attributes !< Add list of attributes name/value pairs passed as stream. procedure , pass ( self ), private :: alloc_attributes !< Allocate (prepare for filling) dynamic memory of attributes. procedure , pass ( self ), private :: delete_single_attribute !< Delete one attribute name/value pair. procedure , pass ( self ), private :: delete_multiple_attributes !< Delete list of attributes name/value pairs. procedure , pass ( self ), private :: get !< Get the tag value and attributes from source. procedure , pass ( self ), private :: get_value !< Get the tag value from source after tag_name has been set. procedure , pass ( self ), private :: get_attributes !< Get the attributes values from source. procedure , pass ( self ), private :: parse_attributes_names !< Parse the tag attributes names contained into a string. procedure , pass ( self ), private :: search !< Search tag named *tag_name* into a string. ! operators procedure , pass ( lhs ), private :: assign_tag !< Assignment between two tags. final :: finalize !< Free dynamic memory when finalizing. endtype xml_tag","tags":"","url":"type/xml_tag.html"},{"title":"xml_file – FoXy ","text":"type, public :: xml_file XML file class. Inherits type~~xml_file~~InheritsGraph type~xml_file xml_file type~xml_tag xml_tag type~xml_file->type~xml_tag tag string string type~xml_tag->string tag_name, tag_content, attribute Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( xml_tag ), private, allocatable :: tag (:) XML tags array. integer(kind=I4P), private :: nt = 0_I4P Number of XML tags. Finalization Procedures final :: finalize Free dynamic memory when finalizing. private  subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( xml_file ), intent(inout) :: self XML file. Type-Bound Procedures procedure, public, pass(self) :: add_tag Add tag to XML file. private elemental subroutine add_tag (self, tag) Add tag to XML file. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. type( xml_tag ), intent(in) :: tag XML tag. procedure, public, pass(self) :: content Return tag content of tag named name . private pure function content (self, name) Return tag content of tag named name . Read more… Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. character(len=*), intent(in) :: name Tag name. Return Value character(len=:), allocatable Tag content. procedure, public, pass(self) :: delete_tag Add tag from XML file. private elemental subroutine delete_tag (self, name) Delete tag from XML file. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. character(len=*), intent(in) :: name XML tag name. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. procedure, public, pass(self) :: parse Parse xml file. private  subroutine parse (self, string, filename) Parse xml data from string or file.\nXML data is linearized, a DOM structured is used. Read more… Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. character(len=*), intent(in), optional :: string String containing xml data. character(len=*), intent(in), optional :: filename File name containing xml data. procedure, public, pass(self) :: stringify Convert the whole file data into a string. private pure function stringify (self, linearize) result(string) Convert the whole file data into a string. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. logical, intent(in), optional :: linearize Return a \"linearized\" string of tags without the XML hieararchy. Return Value character(len=:), allocatable Output string containing the whole xml file. procedure, private, pass(self) :: add_child Add child ID to tag children list. private pure subroutine add_child (self, parent_id, child_id) Add child ID to tag children list. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file handler. integer(kind=I4P), intent(in) :: parent_id Parent ID. integer(kind=I4P), intent(in) :: child_id Child ID. procedure, private, pass(self) :: parse_from_string Parse xml data from string. private pure subroutine parse_from_string (self, source_string) Parse xml data from a chunk of source string (file stringified for IO on device). Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file handler. character(len=*), intent(in) :: source_string String containing xml data. procedure, private, pass(self) :: stringify_recursive Convert recursively tags with children into a string. private pure recursive subroutine stringify_recursive (self, tag, is_done, tag_string) Convert recursively tags with children into a string. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. type( xml_tag ), intent(in) :: tag XML tag with children. logical, intent(inout) :: is_done (:) List of stringified tags. character(len=:), intent(inout), allocatable :: tag_string Output string containing the current tag. Source Code type , public :: xml_file !< XML file class. private type ( xml_tag ), allocatable :: tag (:) !< XML tags array. integer ( I4P ) :: nt = 0_I4P !< Number of XML tags. contains ! public methods procedure , pass ( self ) :: add_tag !< Add tag to XML file. procedure , pass ( self ) :: content !< Return tag content of tag named *name*. procedure , pass ( self ) :: delete_tag !< Add tag from XML file. procedure , pass ( self ) :: free !< Free dynamic memory. procedure , pass ( self ) :: parse !< Parse xml file. procedure , pass ( self ) :: stringify !< Convert the whole file data into a string. ! private methods procedure , pass ( self ), private :: add_child !< Add child ID to tag children list. procedure , pass ( self ), private :: parse_from_string !< Parse xml data from string. procedure , pass ( self ), private :: stringify_recursive !< Convert recursively tags with children into a string. ! operators final :: finalize !< Free dynamic memory when finalizing. endtype xml_file","tags":"","url":"type/xml_file.html"},{"title":"create_tag_flat – FoXy","text":"private pure function create_tag_flat(name, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, content, indent, is_content_indented, is_self_closing, id, level, parent_id, attributes_stream_alloc, content_alloc) result(tag) Return an instance of xml tag. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Tag name. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list as single stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. character(len=*), intent(in), optional :: content Tag value. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate content indentation. logical, intent(in), optional :: is_self_closing The tag is self closing. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Return Value type( xml_tag ) XML tag. Calls proc~~create_tag_flat~~CallsGraph proc~create_tag_flat create_tag_flat proc~set xml_tag%set proc~create_tag_flat->proc~set proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~create_tag_flat~~CalledByGraph proc~create_tag_flat create_tag_flat interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_flat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function create_tag_flat ( name , attribute , attributes , attributes_stream , sanitize_attributes_value , pos , content , & indent , is_content_indented , is_self_closing , id , level , parent_id , attributes_stream_alloc , & content_alloc ) result ( tag ) !< Return an instance of xml tag. character ( * ), intent ( in ) :: name !< Tag name. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list as single stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. integer ( I4P ), intent ( in ), optional :: pos ( 1 :) !< Characters position (in source) indexes. character ( * ), intent ( in ), optional :: content !< Tag value. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate content indentation. logical , intent ( in ), optional :: is_self_closing !< The tag is self closing. integer ( I4P ), intent ( in ), optional :: id !< Uniq ID. integer ( I4P ), intent ( in ), optional :: level !< Tag hierarchy level. integer ( I4P ), intent ( in ), optional :: parent_id !< Parent uniq ID. character (:), allocatable , intent ( in ), optional :: attributes_stream_alloc !< Attributes list stream, allocatable input. character (:), allocatable , intent ( in ), optional :: content_alloc !< Tag value, allocatable input. type ( xml_tag ) :: tag !< XML tag. call tag % set ( name = name , & attribute = attribute , & attributes = attributes , & attributes_stream = attributes_stream , & sanitize_attributes_value = sanitize_attributes_value , & content = content , & pos = pos , & indent = indent , & is_content_indented = is_content_indented , & is_self_closing = is_self_closing , & id = id , & level = level , & parent_id = parent_id , & attributes_stream_alloc = attributes_stream_alloc , & content_alloc = content_alloc ) endfunction create_tag_flat","tags":"","url":"proc/create_tag_flat.html"},{"title":"create_tag_nested – FoXy","text":"private pure function create_tag_nested(name, content, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, indent, is_content_indented, id, level, parent_id, attributes_stream_alloc, content_alloc) result(tag) Return an instance of xml tag with value being a nested tag. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Tag name. type( xml_tag ), intent(in) :: content Tag value as nested tag.. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list as single stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate value indentation. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Return Value type( xml_tag ) XML tag. Calls proc~~create_tag_nested~~CallsGraph proc~create_tag_nested create_tag_nested proc~set xml_tag%set proc~create_tag_nested->proc~set proc~stringify xml_tag%stringify proc~create_tag_nested->proc~stringify proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~create_tag_nested~~CalledByGraph proc~create_tag_nested create_tag_nested interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_nested Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function create_tag_nested ( name , content , attribute , attributes , attributes_stream , sanitize_attributes_value , pos , indent ,& is_content_indented , id , level , parent_id , attributes_stream_alloc , content_alloc ) result ( tag ) !< Return an instance of xml tag with value being a nested tag. character ( * ), intent ( in ) :: name !< Tag name. type ( xml_tag ), intent ( in ) :: content !< Tag value as nested tag.. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list as single stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. integer ( I4P ), intent ( in ), optional :: pos ( 1 :) !< Characters position (in source) indexes. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate value indentation. integer ( I4P ), intent ( in ), optional :: id !< Uniq ID. integer ( I4P ), intent ( in ), optional :: level !< Tag hierarchy level. integer ( I4P ), intent ( in ), optional :: parent_id !< Parent uniq ID. character (:), allocatable , intent ( in ), optional :: attributes_stream_alloc !< Attributes list stream, allocatable input. character (:), allocatable , intent ( in ), optional :: content_alloc !< Tag value, allocatable input. type ( xml_tag ) :: tag !< XML tag. call tag % set ( name = name , & attribute = attribute , & attributes = attributes , & content = content % stringify (), & sanitize_attributes_value = sanitize_attributes_value , & attributes_stream = attributes_stream , & pos = pos , & indent = indent , & is_content_indented = is_content_indented , & id = id , & level = level , & parent_id = parent_id , & attributes_stream_alloc = attributes_stream_alloc , & content_alloc = content_alloc ) endfunction create_tag_nested","tags":"","url":"proc/create_tag_nested.html"},{"title":"attributes – FoXy","text":"private pure function attributes(self) result(att_) Return attributes name/value pairs as string. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value character(len=:), allocatable The attributes string. Source Code pure function create_tag_flat ( name , attribute , attributes , attributes_stream , sanitize_attributes_value , pos , content , & indent , is_content_indented , is_self_closing , id , level , parent_id , attributes_stream_alloc , & content_alloc ) result ( tag ) !< Return an instance of xml tag. character ( * ), intent ( in ) :: name !< Tag name. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list as single stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. integer ( I4P ), intent ( in ), optional :: pos ( 1 :) !< Characters position (in source) indexes. character ( * ), intent ( in ), optional :: content !< Tag value. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate content indentation. logical , intent ( in ), optional :: is_self_closing !< The tag is self closing. integer ( I4P ), intent ( in ), optional :: id !< Uniq ID. integer ( I4P ), intent ( in ), optional :: level !< Tag hierarchy level. integer ( I4P ), intent ( in ), optional :: parent_id !< Parent uniq ID. character (:), allocatable , intent ( in ), optional :: attributes_stream_alloc !< Attributes list stream, allocatable input. character (:), allocatable , intent ( in ), optional :: content_alloc !< Tag value, allocatable input. type ( xml_tag ) :: tag !< XML tag. call tag % set ( name = name , & attribute = attribute , & attributes = attributes , & attributes_stream = attributes_stream , & sanitize_attributes_value = sanitize_attributes_value , & content = content , & pos = pos , & indent = indent , & is_content_indented = is_content_indented , & is_self_closing = is_self_closing , & id = id , & level = level , & parent_id = parent_id , & attributes_stream_alloc = attributes_stream_alloc , & content_alloc = content_alloc ) endfunction create_tag_flat pure function create_tag_nested ( name , content , attribute , attributes , attributes_stream , sanitize_attributes_value , pos , indent ,& is_content_indented , id , level , parent_id , attributes_stream_alloc , content_alloc ) result ( tag ) !< Return an instance of xml tag with value being a nested tag. character ( * ), intent ( in ) :: name !< Tag name. type ( xml_tag ), intent ( in ) :: content !< Tag value as nested tag.. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list as single stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. integer ( I4P ), intent ( in ), optional :: pos ( 1 :) !< Characters position (in source) indexes. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate value indentation. integer ( I4P ), intent ( in ), optional :: id !< Uniq ID. integer ( I4P ), intent ( in ), optional :: level !< Tag hierarchy level. integer ( I4P ), intent ( in ), optional :: parent_id !< Parent uniq ID. character (:), allocatable , intent ( in ), optional :: attributes_stream_alloc !< Attributes list stream, allocatable input. character (:), allocatable , intent ( in ), optional :: content_alloc !< Tag value, allocatable input. type ( xml_tag ) :: tag !< XML tag. call tag % set ( name = name , & attribute = attribute , & attributes = attributes , & content = content % stringify (), & sanitize_attributes_value = sanitize_attributes_value , & attributes_stream = attributes_stream , & pos = pos , & indent = indent , & is_content_indented = is_content_indented , & id = id , & level = level , & parent_id = parent_id , & attributes_stream_alloc = attributes_stream_alloc , & content_alloc = content_alloc ) endfunction create_tag_nested ! public methods pure subroutine add_child_id ( self , child_id ) !< Add child ID to children IDs list. class ( xml_tag ), intent ( inout ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: child_id !< Child ID. if ( allocated ( self % child_id )) then self % child_id = [ self % child_id , child_id ] else self % child_id = [ child_id ] endif self % children_number = size ( self % child_id ) endsubroutine add_child_id pure function attributes ( self ) result ( att_ ) !< Return attributes name/value pairs as string. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( len = :), allocatable :: att_ !< The attributes string. integer ( I4P ) :: a !< Counter. if ( self % attributes_number > 0 ) then att_ = '' do a = 1 , self % attributes_number att_ = att_ // ' ' // self % attribute ( 1 , a ) // '=\"' // self % attribute ( 2 , a ) // '\"' enddo att_ = trim ( adjustl ( att_ )) endif endfunction attributes","tags":"","url":"proc/attributes.html"},{"title":"end_tag – FoXy","text":"private pure function end_tag(self, is_indented) result(tag_) Return </tag_name> end tag. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Activate content indentation. Return Value character(len=:), allocatable The end tag string. Called by proc~~end_tag~~CalledByGraph proc~end_tag xml_tag%end_tag proc~stringify xml_tag%stringify proc~stringify->proc~end_tag proc~create_tag_nested create_tag_nested proc~create_tag_nested->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive proc~stringify~2 xml_file%stringify proc~stringify~2->proc~stringify proc~stringify~2->proc~stringify_recursive proc~write_tag xml_tag%write_tag proc~write_tag->proc~stringify program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->proc~stringify program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~stringify program~foxy_test_delete_attributes foxy_test_delete_attributes program~foxy_test_delete_attributes->proc~stringify program~foxy_test_delete_content foxy_test_delete_content program~foxy_test_delete_content->proc~stringify program~foxy_test_indent_tag foxy_test_indent_tag program~foxy_test_indent_tag->proc~stringify interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_nested program~foxy_test_add_tag foxy_test_add_tag program~foxy_test_add_tag->proc~stringify~2 program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~stringify~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~stringify~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~stringify~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~stringify~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~stringify~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function end_tag ( self , is_indented ) result ( tag_ ) !< Return `</tag_name>` end tag. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Activate content indentation. character ( len = :), allocatable :: tag_ !< The end tag string. tag_ = '</' // self % tag_name // '>' if ( present ( is_indented )) then if ( is_indented ) tag_ = repeat ( ' ' , self % indent ) // tag_ endif endfunction end_tag","tags":"","url":"proc/end_tag.html"},{"title":"is_attribute_present – FoXy","text":"private pure function is_attribute_present(self, name) result(is_present) Return .true. it the queried attribute name is defined, .false. otherwise. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. character(len=*), intent(in) :: name Attribute name. Return Value logical Inquire result. Source Code pure function is_attribute_present ( self , name ) result ( is_present ) !< Return .true. it the queried attribute name is defined, .false. otherwise. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( * ), intent ( in ) :: name !< Attribute name. logical :: is_present !< Inquire result. integer ( I4P ) :: a !< Counter. is_present = . false . if ( self % attributes_number > 0 ) then do a = 1 , self % attributes_number if ( self % attribute ( 1 , a ) == name ) then is_present = . true . exit endif enddo endif endfunction is_attribute_present","tags":"","url":"proc/is_attribute_present.html"},{"title":"is_parsed – FoXy","text":"private elemental function is_parsed(self) Check is tag is correctly parsed, i.e. its tag_name is allocated. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value logical Result of check. Calls proc~~is_parsed~~CallsGraph proc~is_parsed xml_tag%is_parsed is_allocated is_allocated proc~is_parsed->is_allocated Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_parsed ( self ) !< Check is tag is correctly parsed, i.e. its *tag_name* is allocated. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical :: is_parsed !< Result of check. is_parsed = self % tag_name % is_allocated () endfunction is_parsed","tags":"","url":"proc/is_parsed.html"},{"title":"name – FoXy","text":"private pure function name(self) Return tag name. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value character(len=:), allocatable XML tag name. Calls proc~~name~~CallsGraph proc~name xml_tag%name chars chars proc~name->chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~name~~CalledByGraph proc~name xml_tag%name proc~delete_tag xml_file%delete_tag proc~delete_tag->proc~name program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~delete_tag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function name ( self ) !< Return tag name. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( len = :), allocatable :: name !< XML tag name. name = self % tag_name % chars () endfunction name","tags":"","url":"proc/name.html"},{"title":"self_closing_tag – FoXy","text":"private pure function self_closing_tag(self, is_indented) result(tag_) Return <tag_name.../> self closing tag. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Flag to check if tag is indented. Return Value character(len=:), allocatable The self closing tag string. Called by proc~~self_closing_tag~~CalledByGraph proc~self_closing_tag xml_tag%self_closing_tag proc~stringify xml_tag%stringify proc~stringify->proc~self_closing_tag proc~create_tag_nested create_tag_nested proc~create_tag_nested->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive proc~stringify~2 xml_file%stringify proc~stringify~2->proc~stringify proc~stringify~2->proc~stringify_recursive proc~write_tag xml_tag%write_tag proc~write_tag->proc~stringify program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->proc~stringify program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~stringify program~foxy_test_delete_attributes foxy_test_delete_attributes program~foxy_test_delete_attributes->proc~stringify program~foxy_test_delete_content foxy_test_delete_content program~foxy_test_delete_content->proc~stringify program~foxy_test_indent_tag foxy_test_indent_tag program~foxy_test_indent_tag->proc~stringify interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_nested program~foxy_test_add_tag foxy_test_add_tag program~foxy_test_add_tag->proc~stringify~2 program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~stringify~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~stringify~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~stringify~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~stringify~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~stringify~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function self_closing_tag ( self , is_indented ) result ( tag_ ) !< Return `<tag_name.../>` self closing tag. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Flag to check if tag is indented. character ( len = :), allocatable :: tag_ !< The self closing tag string. tag_ = '<' // self % tag_name if ( self % attributes_number > 0 ) tag_ = tag_ // ' ' // self % attributes () tag_ = tag_ // '/>' if ( present ( is_indented )) then if ( is_indented ) tag_ = repeat ( ' ' , self % indent ) // tag_ endif endfunction self_closing_tag","tags":"","url":"proc/self_closing_tag.html"},{"title":"start_tag – FoXy","text":"private pure function start_tag(self, is_indented) result(tag_) Return <tag_name...> start tag. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Flag to check if tag is indented. Return Value character(len=:), allocatable The start tag string. Called by proc~~start_tag~~CalledByGraph proc~start_tag xml_tag%start_tag proc~stringify xml_tag%stringify proc~stringify->proc~start_tag proc~create_tag_nested create_tag_nested proc~create_tag_nested->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive proc~stringify~2 xml_file%stringify proc~stringify~2->proc~stringify proc~stringify~2->proc~stringify_recursive proc~write_tag xml_tag%write_tag proc~write_tag->proc~stringify program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->proc~stringify program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~stringify program~foxy_test_delete_attributes foxy_test_delete_attributes program~foxy_test_delete_attributes->proc~stringify program~foxy_test_delete_content foxy_test_delete_content program~foxy_test_delete_content->proc~stringify program~foxy_test_indent_tag foxy_test_indent_tag program~foxy_test_indent_tag->proc~stringify interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_nested program~foxy_test_add_tag foxy_test_add_tag program~foxy_test_add_tag->proc~stringify~2 program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~stringify~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~stringify~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~stringify~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~stringify~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~stringify~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function start_tag ( self , is_indented ) result ( tag_ ) !< Return `<tag_name...>` start tag. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Flag to check if tag is indented. character ( len = :), allocatable :: tag_ !< The start tag string. tag_ = '<' // self % tag_name if ( self % attributes_number > 0 ) tag_ = tag_ // ' ' // self % attributes () tag_ = tag_ // '>' if ( present ( is_indented )) then if ( is_indented ) tag_ = repeat ( ' ' , self % indent ) // tag_ endif endfunction start_tag","tags":"","url":"proc/start_tag.html"},{"title":"stringify – FoXy","text":"private pure function stringify(self, is_indented, is_content_indented, only_start, only_content, only_end, linearize) result(stringed) Convert the whole tag into a string. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Activate content indentation. logical, intent(in), optional :: is_content_indented Activate content indentation. logical, intent(in), optional :: only_start Write only start tag. logical, intent(in), optional :: only_content Write only content. logical, intent(in), optional :: only_end Write only end tag. logical, intent(in), optional :: linearize Return a \"linearized\" string of tags without the XML hieararchy. Return Value character(len=:), allocatable Output string containing the whole tag. Calls proc~~stringify~~CallsGraph proc~stringify xml_tag%stringify chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~stringify~~CalledByGraph proc~stringify xml_tag%stringify proc~create_tag_nested create_tag_nested proc~create_tag_nested->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive proc~stringify~2 xml_file%stringify proc~stringify~2->proc~stringify proc~stringify~2->proc~stringify_recursive proc~write_tag xml_tag%write_tag proc~write_tag->proc~stringify program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->proc~stringify program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~stringify program~foxy_test_delete_attributes foxy_test_delete_attributes program~foxy_test_delete_attributes->proc~stringify program~foxy_test_delete_content foxy_test_delete_content program~foxy_test_delete_content->proc~stringify program~foxy_test_indent_tag foxy_test_indent_tag program~foxy_test_indent_tag->proc~stringify interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_nested program~foxy_test_add_tag foxy_test_add_tag program~foxy_test_add_tag->proc~stringify~2 program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~stringify~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~stringify~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~stringify~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~stringify~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~stringify~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function stringify ( self , is_indented , is_content_indented , only_start , only_content , only_end , linearize ) result ( stringed ) !< Convert the whole tag into a string. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Activate content indentation. logical , intent ( in ), optional :: is_content_indented !< Activate content indentation. logical , intent ( in ), optional :: only_start !< Write only start tag. logical , intent ( in ), optional :: only_content !< Write only content. logical , intent ( in ), optional :: only_end !< Write only end tag. logical , intent ( in ), optional :: linearize !< Return a \"linearized\" string of tags without the XML hieararchy. logical :: linearize_ !< Linearize sentinel, local var. character ( len = :), allocatable :: stringed !< Output string containing the whole tag. logical :: is_content_indented_ !< Activate content indentation. logical :: only_start_ !< Write only start tag. logical :: only_content_ !< Write only content. logical :: only_end_ !< Write only end tag. linearize_ = . false . ; if ( present ( linearize )) linearize_ = linearize if ( linearize_ ) then stringed = '' stringed = stringed // 'name:            \"' // self % tag_name // '\"' // new_line ( 'a' ) if ( self % attributes_number > 0 ) stringed = stringed // 'attributes:      \"' // self % attributes () // '\"' // new_line ( 'a' ) stringed = stringed // 'char pos indexes:\"' // trim ( str ( self % pos )) // '\"' // new_line ( 'a' ) stringed = stringed // 'content:         \"' // self % tag_content // '\"' // new_line ( 'a' ) stringed = stringed // 'indent:          \"' // trim ( str ( self % indent )) // '\"' // new_line ( 'a' ) stringed = stringed // 'is self closing: \"' // trim ( str ( self % is_self_closing )) // '\"' // new_line ( 'a' ) stringed = stringed // 'level:           \"' // trim ( str ( self % level )) // '\"' // new_line ( 'a' ) stringed = stringed // 'id:              \"' // trim ( str ( self % id )) // '\"' // new_line ( 'a' ) stringed = stringed // 'parent id:       \"' // trim ( str ( self % parent_id )) // '\"' // new_line ( 'a' ) stringed = stringed // 'children number: \"' // trim ( str ( self % children_number )) // '\"' // new_line ( 'a' ) if ( allocated ( self % child_id )) stringed = stringed // 'children ids:    \"' // trim ( str ( self % child_id )) // '\"' // new_line ( 'a' ) else is_content_indented_ = . false . ; if ( present ( is_content_indented )) is_content_indented_ = is_content_indented only_start_ = . false . ; if ( present ( only_start )) only_start_ = only_start only_content_ = . false . ; if ( present ( only_content )) only_content_ = only_content only_end_ = . false . ; if ( present ( only_end )) only_end_ = only_end if ( only_start_ ) then stringed = self % start_tag ( is_indented = is_indented ) elseif ( only_content_ ) then if ( self % tag_content % is_allocated ()) then if ( is_content_indented_ ) then stringed = repeat ( ' ' , self % indent + 2 ) // self % tag_content else stringed = self % tag_content % chars () endif endif elseif ( only_end_ ) then stringed = self % end_tag ( is_indented = is_indented ) else stringed = '' if ( self % tag_name % is_allocated ()) then if ( self % is_self_closing ) then stringed = self % self_closing_tag ( is_indented = is_indented ) else stringed = self % start_tag ( is_indented = is_indented ) if ( self % tag_content % is_allocated ()) then if ( is_content_indented_ ) then stringed = stringed // new_line ( 'a' ) // repeat ( ' ' , self % indent + 2 ) // & self % tag_content // new_line ( 'a' ) // repeat ( ' ' , self % indent ) else stringed = stringed // self % tag_content endif endif stringed = stringed // self % end_tag () endif endif endif endif endfunction stringify","tags":"","url":"proc/stringify.html"},{"title":"add_child_id – FoXy","text":"private pure subroutine add_child_id(self, child_id) Add child ID to children IDs list. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. integer(kind=I4P), intent(in) :: child_id Child ID. Called by proc~~add_child_id~~CalledByGraph proc~add_child_id xml_tag%add_child_id proc~add_child xml_file%add_child proc~add_child->proc~add_child_id proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~add_child proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine add_child_id ( self , child_id ) !< Add child ID to children IDs list. class ( xml_tag ), intent ( inout ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: child_id !< Child ID. if ( allocated ( self % child_id )) then self % child_id = [ self % child_id , child_id ] else self % child_id = [ child_id ] endif self % children_number = size ( self % child_id ) endsubroutine add_child_id","tags":"","url":"proc/add_child_id.html"},{"title":"free – FoXy","text":"private elemental subroutine free(self) Free (reset) tag. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. Source Code elemental subroutine free ( self ) !< Free (reset) tag. class ( xml_tag ), intent ( inout ) :: self !< XML tag. integer ( I4P ) :: i , j !< Counter. call self % tag_name % free call self % tag_content % free self % pos = 0_I4P if ( allocated ( self % attribute )) then do j = 1 , size ( self % attribute , dim = 2 ) do i = 1 , size ( self % attribute , dim = 1 ) call self % attribute ( i , j )% free enddo enddo deallocate ( self % attribute ) self % attributes_number = 0_I4P endif self % indent = 0_I4P self % is_self_closing = . false . self % level = 0_I4P self % id = 0_I4P self % parent_id = 0_I4P self % children_number = 0_I4P if ( allocated ( self % child_ID )) deallocate ( self % child_ID ) endsubroutine free","tags":"","url":"proc/free.html"},{"title":"get_content – FoXy","text":"private pure subroutine get_content(self, name, content) Return tag content of self (or its nested tags) if named name . Note If there is no value, the content string is returned deallocated. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. character(len=*), intent(in) :: name Searched tag name. character(len=:), intent(out), allocatable :: content Tag content. Calls proc~~get_content~~CallsGraph proc~get_content xml_tag%get_content chars chars proc~get_content->chars is_allocated is_allocated proc~get_content->is_allocated proc~search xml_tag%search proc~get_content->proc~search proc~search->is_allocated proc~parse xml_tag%parse proc~search->proc~parse proc~parse->is_allocated proc~get xml_tag%get proc~parse->proc~get proc~parse_attributes_names xml_tag%parse_attributes_names proc~parse->proc~parse_attributes_names proc~parse_tag_name xml_tag%parse_tag_name proc~parse->proc~parse_tag_name proc~get_attributes xml_tag%get_attributes proc~get->proc~get_attributes proc~get_value xml_tag%get_value proc~get->proc~get_value proc~alloc_attributes xml_tag%alloc_attributes proc~parse_attributes_names->proc~alloc_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_content~~CalledByGraph proc~get_content xml_tag%get_content proc~content xml_file%content proc~content->proc~get_content Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine get_content ( self , name , content ) !< Return tag content of self (or its nested tags) if named *name*. !< !< @note If there is no value, the *content* string is returned deallocated. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( * ), intent ( in ) :: name !< Searched tag name. character ( len = :), allocatable , intent ( out ) :: content !< Tag content. type ( xml_tag ) :: tag !< Dummy XML tag. if ( allocated ( content )) deallocate ( content ) if ( self % tag_name % is_allocated ()) then if ( self % tag_name == name ) then if ( self % tag_content % is_allocated ()) content = self % tag_content % chars () else if ( self % tag_content % is_allocated ()) then call tag % search ( tag_name = name , source = self % tag_content % chars ()) if ( tag % tag_content % is_allocated ()) content = tag % tag_content % chars () endif endif endif endsubroutine get_content","tags":"","url":"proc/get_content.html"},{"title":"parse – FoXy","text":"private elemental subroutine parse(self, source, tstart, tend) Parse the tag contained into a source string. It is assumed that the first tag contained into the source string is parsed, the others eventually present are omitted.\nValid syntax are:\n+ <tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name> + <tag_name att1=\"att1 val\" att2=\"att2 val\".../> Note Inside the attributes value the symbols < and > are not allowed. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the string. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the string. Calls proc~~parse~~CallsGraph proc~parse xml_tag%parse is_allocated is_allocated proc~parse->is_allocated proc~get xml_tag%get proc~parse->proc~get proc~parse_attributes_names xml_tag%parse_attributes_names proc~parse->proc~parse_attributes_names proc~parse_tag_name xml_tag%parse_tag_name proc~parse->proc~parse_tag_name proc~get_attributes xml_tag%get_attributes proc~get->proc~get_attributes proc~get_value xml_tag%get_value proc~get->proc~get_value proc~alloc_attributes xml_tag%alloc_attributes proc~parse_attributes_names->proc~alloc_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse~~CalledByGraph proc~parse xml_tag%parse proc~search xml_tag%search proc~search->proc~parse program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~parse proc~get_content xml_tag%get_content proc~get_content->proc~search proc~content xml_file%content proc~content->proc~get_content Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine parse ( self , source , tstart , tend ) !< Parse the tag contained into a source string. !< !< It is assumed that the first tag contained into the source string is parsed, the others eventually present are omitted. !< Valid syntax are: !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name>` !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\".../>` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the string. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the string. integer ( I4P ) :: tstartd !< Starting index of tag inside the string. integer ( I4P ) :: tendd !< Ending index of tag inside the string. tstartd = 0 tendd = 0 call self % parse_tag_name ( source = source , tstart = tstartd , tend = tendd ) if ( self % tag_name % is_allocated ()) then if ( index ( string = source ( tstartd : tendd ), substring = '=' ) > 0 ) call self % parse_attributes_names ( source = source ( tstartd : tendd )) if ( index ( string = source , substring = '</' // self % tag_name // '>' ) > 0 ) & tendd = index ( string = source , substring = '</' // self % tag_name // '>' ) + len ( '</' // self % tag_name // '>' ) - 1 call self % get ( source = source ( tstartd : tendd )) endif if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd endsubroutine parse","tags":"","url":"proc/parse.html"},{"title":"parse_tag_name – FoXy","text":"private elemental subroutine parse_tag_name(self, source, tstart, tend) Parse the tag name contained into a string. It is assumed that the first tag contained into the source is parsed, the others eventually present are omitted.\nValid syntax are:\n+ <tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name> + <tag_name att1=\"att1 val\" att2=\"att2 val\".../> Note Inside the attributes value the symbols < and > are not allowed. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the source. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the source. Called by proc~~parse_tag_name~~CalledByGraph proc~parse_tag_name xml_tag%parse_tag_name proc~parse xml_tag%parse proc~parse->proc~parse_tag_name proc~search xml_tag%search proc~search->proc~parse program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~parse proc~get_content xml_tag%get_content proc~get_content->proc~search proc~content xml_file%content proc~content->proc~get_content Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine parse_tag_name ( self , source , tstart , tend ) !< Parse the tag name contained into a string. !< !< It is assumed that the first tag contained into the source is parsed, the others eventually present are omitted. !< Valid syntax are: !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name>` !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\".../>` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the source. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the source. integer ( I4P ) :: tstartd !< Starting index of tag inside the source. integer ( I4P ) :: tendd !< Ending index of tag inside the source. character ( len = 1 ) :: c1 !< Dummy string for parsing file. character ( len = :), allocatable :: c2 !< Dummy string for parsing file. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: s !< Counter. call self % tag_name % free tstartd = 0 tendd = 0 c = 1 Tag_Search : do while ( c <= len ( source )) c1 = source ( c : c ) if ( c1 == '<' . and . source ( c + 1 : c + 1 ) /= '/' ) then tstartd = c c2 = c1 Tag_Name : do while ( c < len ( source )) c = c + 1 ; c1 = source ( c : c ) c2 = c2 // c1 if ( c1 == '>' ) then tendd = c exit Tag_Name endif enddo Tag_Name s = index ( string = c2 , substring = ' ' ) if ( s > 0 ) then ! there are attributes self % tag_name = c2 ( 2 : s - 1 ) else if ( index ( string = c2 , substring = '/>' ) > 0 ) then ! self closing tag self % tag_name = c2 ( 2 : len ( c2 ) - 2 ) else self % tag_name = c2 ( 2 : len ( c2 ) - 1 ) endif endif exit Tag_Search endif c = c + 1 enddo Tag_Search if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd endsubroutine parse_tag_name","tags":"","url":"proc/parse_tag_name.html"},{"title":"set – FoXy","text":"private pure subroutine set(self, name, attribute, attributes, attributes_stream, sanitize_attributes_value, content, pos, indent, is_content_indented, is_self_closing, id, level, parent_id, attributes_stream_alloc, content_alloc) Set tag data. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in), optional :: name Tag name. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list of name/value pairs as stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. character(len=*), intent(in), optional :: content Tag value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate value indentation. logical, intent(in), optional :: is_self_closing The tag is self closing. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Calls proc~~set~~CallsGraph proc~set xml_tag%set proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set~~CalledByGraph proc~set xml_tag%set proc~create_tag_flat create_tag_flat proc~create_tag_flat->proc~set proc~create_tag_nested create_tag_nested proc~create_tag_nested->proc~set proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~set program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~set interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_flat interface~xml_tag->proc~create_tag_nested proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine set ( self , name , attribute , attributes , attributes_stream , sanitize_attributes_value , content , & pos , indent , is_content_indented , is_self_closing , id , level , parent_id , & attributes_stream_alloc , content_alloc ) !< Set tag data. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ), optional :: name !< Tag name. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list of name/value pairs as stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. character ( * ), intent ( in ), optional :: content !< Tag value. integer ( I4P ), intent ( in ), optional :: pos ( 1 :) !< Characters position (in source) indexes. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate value indentation. logical , intent ( in ), optional :: is_self_closing !< The tag is self closing. integer ( I4P ), intent ( in ), optional :: id !< Uniq ID. integer ( I4P ), intent ( in ), optional :: level !< Tag hierarchy level. integer ( I4P ), intent ( in ), optional :: parent_id !< Parent uniq ID. character (:), allocatable , intent ( in ), optional :: attributes_stream_alloc !< Attributes list stream, allocatable input. character (:), allocatable , intent ( in ), optional :: content_alloc !< Tag value, allocatable input. logical :: is_content_indented_ !< Activate value indentation. is_content_indented_ = . false . ; if ( present ( is_content_indented )) is_content_indented_ = is_content_indented if ( present ( name )) self % tag_name = name if ( present ( attribute )) call self % add_single_attribute ( attribute = attribute , sanitize_value = sanitize_attributes_value ) if ( present ( attributes )) call self % add_multiple_attributes ( attributes = attributes , sanitize_values = sanitize_attributes_value ) if ( present ( attributes_stream )) call self % add_stream_attributes ( attributes_stream = attributes_stream , & sanitize_values = sanitize_attributes_value ) if ( present ( pos )) self % pos = pos if ( present ( indent )) self % indent = indent if ( present ( content )) then if ( is_content_indented_ ) then self % tag_content = new_line ( 'a' ) // repeat ( ' ' , self % indent + 2 ) // content // new_line ( 'a' ) else self % tag_content = content endif endif if ( present ( is_self_closing )) self % is_self_closing = is_self_closing if ( present ( id )) self % id = id if ( present ( level )) self % level = level if ( present ( parent_id )) self % parent_id = parent_id if ( present ( attributes_stream_alloc )) then if ( allocated ( attributes_stream_alloc )) call self % add_stream_attributes ( attributes_stream = attributes_stream_alloc , & sanitize_values = sanitize_attributes_value ) endif if ( present ( content_alloc )) then if ( allocated ( content_alloc )) then if ( is_content_indented_ ) then self % tag_content = new_line ( 'a' ) // repeat ( ' ' , self % indent + 2 ) // content_alloc // new_line ( 'a' ) else self % tag_content = content_alloc endif endif endif endsubroutine set","tags":"","url":"proc/set.html"},{"title":"write_tag – FoXy","text":"private  subroutine write_tag(self, unit, is_indented, is_content_indented, form, end_record, only_start, only_content, only_end, iostat, iomsg) Write tag to unit file. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. integer(kind=I4P), intent(in) :: unit File unit. logical, intent(in), optional :: is_indented Activate content indentation. logical, intent(in), optional :: is_content_indented Activate content indentation. character(len=*), intent(in), optional :: form Format. character(len=*), intent(in), optional :: end_record Ending record. logical, intent(in), optional :: only_start Write only start tag. logical, intent(in), optional :: only_content Write only content. logical, intent(in), optional :: only_end Write only end tag. integer(kind=I4P), intent(out), optional :: iostat IO status. character(len=*), intent(out), optional :: iomsg IO message. Calls proc~~write_tag~~CallsGraph proc~write_tag xml_tag%write_tag chars chars proc~write_tag->chars proc~stringify xml_tag%stringify proc~write_tag->proc~stringify upper upper proc~write_tag->upper proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_tag ( self , unit , is_indented , is_content_indented , form , end_record , only_start , only_content , only_end , & iostat , iomsg ) !< Write tag to unit file. class ( xml_tag ), intent ( in ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: unit !< File unit. logical , intent ( in ), optional :: is_indented !< Activate content indentation. logical , intent ( in ), optional :: is_content_indented !< Activate content indentation. character ( * ), intent ( in ), optional :: form !< Format. character ( * ), intent ( in ), optional :: end_record !< Ending record. logical , intent ( in ), optional :: only_start !< Write only start tag. logical , intent ( in ), optional :: only_content !< Write only content. logical , intent ( in ), optional :: only_end !< Write only end tag. integer ( I4P ), intent ( out ), optional :: iostat !< IO status. character ( * ), intent ( out ), optional :: iomsg !< IO message. type ( string ) :: form_ !< Format. type ( string ) :: end_record_ !< Ending record. integer ( I4P ) :: iostat_ !< IO status. character ( 500 ) :: iomsg_ !< IO message. form_ = 'UNFORMATTED' if ( present ( form )) then form_ = form form_ = form_ % upper () endif end_record_ = '' ; if ( present ( end_record )) end_record_ = end_record select case ( form_ % chars ()) case ( 'UNFORMATTED' ) write ( unit = unit , iostat = iostat_ , iomsg = iomsg_ ) self % stringify ( is_indented = is_indented , & is_content_indented = is_content_indented , & only_start = only_start , & only_content = only_content , & only_end = only_end ) // end_record_ case ( 'FORMATTED' ) write ( unit = unit , fmt = '(A)' , iostat = iostat_ , iomsg = iomsg_ ) self % stringify ( is_indented = is_indented , & is_content_indented = is_content_indented , & only_start = only_start , & only_content = only_content , & only_end = only_end ) // end_record_ endselect if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_tag","tags":"","url":"proc/write_tag.html"},{"title":"add_single_attribute – FoXy","text":"private pure subroutine add_single_attribute(self, attribute, sanitize_value) Add one attribute name/value pair. Note Leading and trailing white spaces are trimmed out by attribute's name. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attribute (1:) Attribute name/value pair [1:2]. logical, intent(in), optional :: sanitize_value Sanitize attribute value. Calls proc~~add_single_attribute~~CallsGraph proc~add_single_attribute xml_tag%add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_single_attribute~~CalledByGraph proc~add_single_attribute xml_tag%add_single_attribute none~add_attributes xml_tag%add_attributes none~add_attributes->proc~add_single_attribute proc~add_multiple_attributes xml_tag%add_multiple_attributes none~add_attributes->proc~add_multiple_attributes proc~add_stream_attributes xml_tag%add_stream_attributes none~add_attributes->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~add_stream_attributes->proc~add_single_attribute proc~set xml_tag%set proc~set->proc~add_single_attribute proc~set->proc~add_multiple_attributes proc~set->proc~add_stream_attributes proc~create_tag_flat create_tag_flat proc~create_tag_flat->proc~set proc~create_tag_nested create_tag_nested proc~create_tag_nested->proc~set proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~set program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->none~add_attributes program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~set interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_flat interface~xml_tag->proc~create_tag_nested proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine add_single_attribute ( self , attribute , sanitize_value ) !< Add one attribute name/value pair. !< !< @note Leading and trailing white spaces are trimmed out by attribute's name. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: attribute ( 1 :) !< Attribute name/value pair [1:2]. logical , intent ( in ), optional :: sanitize_value !< Sanitize attribute value. type ( string ), allocatable :: new_attribute (:,:) !< Temporary storage for attributes. logical :: sanitize_value_ !< Sanitize attribute value. logical :: is_updated !< Flag to check if the attribute has been updeted. integer ( I4P ) :: a !< Counter. sanitize_value_ = . false . ; if ( present ( sanitize_value )) sanitize_value_ = sanitize_value if ( self % attributes_number > 0 ) then is_updated = . false . update_if_already_present : do a = 1 , self % attributes_number if ( self % attribute ( 1 , a ) == attribute ( 1 )) then if ( sanitize_value_ ) then self % attribute ( 2 , a ) = trim ( adjustl ( attribute ( 2 ))) else self % attribute ( 2 , a ) = attribute ( 2 ) endif is_updated = . true . exit update_if_already_present endif enddo update_if_already_present if (. not . is_updated ) then allocate ( new_attribute ( 1 : 2 , 1 : self % attributes_number + 1 )) new_attribute ( 1 : 2 , 1 : self % attributes_number ) = self % attribute new_attribute ( 1 , self % attributes_number + 1 ) = trim ( adjustl ( attribute ( 1 ))) if ( sanitize_value_ ) then new_attribute ( 2 , self % attributes_number + 1 ) = trim ( adjustl ( attribute ( 2 ))) else new_attribute ( 2 , self % attributes_number + 1 ) = attribute ( 2 ) endif call move_alloc ( from = new_attribute , to = self % attribute ) self % attributes_number = self % attributes_number + 1 endif else call self % alloc_attributes ( Na = 1 ) self % attribute ( 1 , 1 ) = trim ( adjustl ( attribute ( 1 ))) if ( sanitize_value_ ) then self % attribute ( 2 , 1 ) = trim ( adjustl ( attribute ( 2 ))) else self % attribute ( 2 , 1 ) = attribute ( 2 ) endif endif endsubroutine add_single_attribute","tags":"","url":"proc/add_single_attribute.html"},{"title":"add_multiple_attributes – FoXy","text":"private pure subroutine add_multiple_attributes(self, attributes, sanitize_values) Add list of attributes name/value pairs. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attributes (1:,1:) Attribute name/value pair list [1:2,1:]. logical, intent(in), optional :: sanitize_values Sanitize attribute values. Calls proc~~add_multiple_attributes~~CallsGraph proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_multiple_attributes~~CalledByGraph proc~add_multiple_attributes xml_tag%add_multiple_attributes none~add_attributes xml_tag%add_attributes none~add_attributes->proc~add_multiple_attributes proc~set xml_tag%set proc~set->proc~add_multiple_attributes proc~create_tag_flat create_tag_flat proc~create_tag_flat->proc~set proc~create_tag_nested create_tag_nested proc~create_tag_nested->proc~set proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~set program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->none~add_attributes program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~set interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_flat interface~xml_tag->proc~create_tag_nested proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine add_multiple_attributes ( self , attributes , sanitize_values ) !< Add list of attributes name/value pairs. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: attributes ( 1 :, 1 :) !< Attribute name/value pair list [1:2,1:]. logical , intent ( in ), optional :: sanitize_values !< Sanitize attribute values. integer ( I4P ) :: a !< Counter. do a = 1 , size ( attributes , dim = 2 ) ! not efficient: many reallocation, but safe call self % add_single_attribute ( attribute = attributes ( 1 :, a ), sanitize_value = sanitize_values ) enddo endsubroutine add_multiple_attributes","tags":"","url":"proc/add_multiple_attributes.html"},{"title":"add_stream_attributes – FoXy","text":"private pure subroutine add_stream_attributes(self, attributes_stream, sanitize_values) Add list of attributes name/value pairs passed as stream. Note The character = cannot compare into the attributes names of values. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attributes_stream Attribute name/value pair list passed as stream. logical, intent(in), optional :: sanitize_values Sanitize attribute values. Calls proc~~add_stream_attributes~~CallsGraph proc~add_stream_attributes xml_tag%add_stream_attributes fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition proc~add_single_attribute xml_tag%add_single_attribute proc~add_stream_attributes->proc~add_single_attribute slice slice proc~add_stream_attributes->slice proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_stream_attributes~~CalledByGraph proc~add_stream_attributes xml_tag%add_stream_attributes none~add_attributes xml_tag%add_attributes none~add_attributes->proc~add_stream_attributes proc~set xml_tag%set proc~set->proc~add_stream_attributes proc~create_tag_flat create_tag_flat proc~create_tag_flat->proc~set proc~create_tag_nested create_tag_nested proc~create_tag_nested->proc~set proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~set program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->none~add_attributes program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~set interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_flat interface~xml_tag->proc~create_tag_nested proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine add_stream_attributes ( self , attributes_stream , sanitize_values ) !< Add list of attributes name/value pairs passed as stream. !< !< @note The character `=` cannot compare into the attributes names of values. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: attributes_stream !< Attribute name/value pair list passed as stream. logical , intent ( in ), optional :: sanitize_values !< Sanitize attribute values. type ( string ) :: attributes_string !< Attribute name/value pair list as string. type ( string ) :: tokens ( 1 : 3 ) !< Attributes tokenized by `=`. type ( string ) :: attribute ( 1 : 2 ) !< Attribute name/value pair. logical :: continue_to_parse !< Sentinel to stop attributes stream parsing. integer ( I4P ) :: max_chars !< Counter. attributes_string = attributes_stream continue_to_parse = . true . do while ( continue_to_parse ) tokens = attributes_string % partition ( sep = '=' ) attribute ( 1 ) = trim ( adjustl ( tokens ( 1 ))) if ( attribute ( 1 ) /= '' ) then tokens ( 3 ) = tokens ( 3 )% slice ( istart = tokens ( 3 )% index ( '\"' ) + 1 , iend = tokens ( 3 )% len ()) attribute ( 2 ) = tokens ( 3 )% slice ( istart = 1 , iend = tokens ( 3 )% index ( '\"' ) - 1 ) tokens ( 3 ) = tokens ( 3 )% slice ( istart = tokens ( 3 )% index ( '\"' ) + 1 , iend = tokens ( 3 )% len ()) max_chars = max ( attribute ( 1 )% len (), attribute ( 2 )% len ()) attribute ( 1 ) = attribute ( 1 )% fill ( width = max_chars , right = . true ., filling_char = ' ' ) attribute ( 2 ) = attribute ( 2 )% fill ( width = max_chars , right = . true ., filling_char = ' ' ) call self % add_single_attribute ( attribute = [ attribute ( 1 ) // '' , attribute ( 2 ) // '' ], sanitize_value = sanitize_values ) if ( tokens ( 3 )% index ( '=' ) > 0 ) then attributes_string = tokens ( 3 ) else continue_to_parse = . false . endif else continue_to_parse = . false . endif enddo endsubroutine add_stream_attributes","tags":"","url":"proc/add_stream_attributes.html"},{"title":"alloc_attributes – FoXy","text":"private elemental subroutine alloc_attributes(self, Na) Allocate (prepare for filling) dynamic memory of attributes. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. integer(kind=I4P), intent(in) :: Na Number of attributes. Called by proc~~alloc_attributes~~CalledByGraph proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~add_single_attribute->proc~alloc_attributes proc~parse_attributes_names xml_tag%parse_attributes_names proc~parse_attributes_names->proc~alloc_attributes none~add_attributes xml_tag%add_attributes none~add_attributes->proc~add_single_attribute proc~add_multiple_attributes xml_tag%add_multiple_attributes none~add_attributes->proc~add_multiple_attributes proc~add_stream_attributes xml_tag%add_stream_attributes none~add_attributes->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~add_stream_attributes->proc~add_single_attribute proc~parse xml_tag%parse proc~parse->proc~parse_attributes_names proc~set xml_tag%set proc~set->proc~add_single_attribute proc~set->proc~add_multiple_attributes proc~set->proc~add_stream_attributes proc~create_tag_flat create_tag_flat proc~create_tag_flat->proc~set proc~create_tag_nested create_tag_nested proc~create_tag_nested->proc~set proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~set proc~search xml_tag%search proc~search->proc~parse program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->none~add_attributes program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~parse program~foxy_test_create_tag->proc~set interface~xml_tag xml_tag interface~xml_tag->proc~create_tag_flat interface~xml_tag->proc~create_tag_nested proc~get_content xml_tag%get_content proc~get_content->proc~search proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string proc~content xml_file%content proc~content->proc~get_content program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine alloc_attributes ( self , Na ) !< Allocate (prepare for filling) dynamic memory of attributes. class ( xml_tag ), intent ( inout ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: Na !< Number of attributes. if ( allocated ( self % attribute )) then call self % attribute % free deallocate ( self % attribute ) endif allocate ( self % attribute ( 1 : 2 , 1 : Na )) self % attributes_number = Na endsubroutine alloc_attributes","tags":"","url":"proc/alloc_attributes.html"},{"title":"delete_content – FoXy","text":"private pure subroutine delete_content(self) Delete tag content. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. Called by proc~~delete_content~~CalledByGraph proc~delete_content xml_tag%delete_content program~foxy_test_delete_content foxy_test_delete_content program~foxy_test_delete_content->proc~delete_content Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine delete_content ( self ) !< Delete tag content. class ( xml_tag ), intent ( inout ) :: self !< XML tag. call self % tag_content % free endsubroutine delete_content","tags":"","url":"proc/delete_content.html"},{"title":"delete_single_attribute – FoXy","text":"private pure subroutine delete_single_attribute(self, name) Delete one attribute name/value pair. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: name Attribute name. Called by proc~~delete_single_attribute~~CalledByGraph proc~delete_single_attribute xml_tag%delete_single_attribute none~delete_attributes xml_tag%delete_attributes none~delete_attributes->proc~delete_single_attribute proc~delete_multiple_attributes xml_tag%delete_multiple_attributes none~delete_attributes->proc~delete_multiple_attributes proc~delete_multiple_attributes->proc~delete_single_attribute program~foxy_test_delete_attributes foxy_test_delete_attributes program~foxy_test_delete_attributes->none~delete_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine delete_single_attribute ( self , name ) !< Delete one attribute name/value pair. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: name !< Attribute name. type ( string ), allocatable :: new_attribute (:,:) !< Temporary storage for attributes. integer ( I4P ) :: a !< Counter. if ( self % attributes_number > 0 ) then search_tag : do a = 1 , self % attributes_number if ( self % attribute ( 1 , a ) == name ) then if ( self % attributes_number > 1 ) then allocate ( new_attribute ( 1 : 2 , 1 : self % attributes_number - 1 )) if ( a == 1 ) then new_attribute (:, a :) = self % attribute (:, a + 1 :) elseif ( a == self % attributes_number ) then new_attribute (:, : a - 1 ) = self % attribute (:, : a - 1 ) else new_attribute (:, : a - 1 ) = self % attribute (:, : a - 1 ) new_attribute (:, a :) = self % attribute (:, a + 1 :) endif call move_alloc ( from = new_attribute , to = self % attribute ) else call self % attribute % free deallocate ( self % attribute ) endif self % attributes_number = self % attributes_number - 1 exit search_tag endif enddo search_tag endif endsubroutine delete_single_attribute","tags":"","url":"proc/delete_single_attribute.html"},{"title":"delete_multiple_attributes – FoXy","text":"private pure subroutine delete_multiple_attributes(self, name) Delete list of attributes name/value pairs. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: name (1:) Attributes names. Calls proc~~delete_multiple_attributes~~CallsGraph proc~delete_multiple_attributes xml_tag%delete_multiple_attributes proc~delete_single_attribute xml_tag%delete_single_attribute proc~delete_multiple_attributes->proc~delete_single_attribute Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~delete_multiple_attributes~~CalledByGraph proc~delete_multiple_attributes xml_tag%delete_multiple_attributes none~delete_attributes xml_tag%delete_attributes none~delete_attributes->proc~delete_multiple_attributes program~foxy_test_delete_attributes foxy_test_delete_attributes program~foxy_test_delete_attributes->none~delete_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine delete_multiple_attributes ( self , name ) !< Delete list of attributes name/value pairs. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: name ( 1 :) !< Attributes names. integer ( I4P ) :: a !< Counter. do a = 1 , size ( name , dim = 1 ) call self % delete_single_attribute ( name = name ( a )) enddo endsubroutine delete_multiple_attributes","tags":"","url":"proc/delete_multiple_attributes.html"},{"title":"get – FoXy","text":"private elemental subroutine get(self, source) Get the tag content and attributes from source after tag_name and attributes names have been set. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. Calls proc~~get~~CallsGraph proc~get xml_tag%get proc~get_attributes xml_tag%get_attributes proc~get->proc~get_attributes proc~get_value xml_tag%get_value proc~get->proc~get_value Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get~~CalledByGraph proc~get xml_tag%get proc~parse xml_tag%parse proc~parse->proc~get proc~search xml_tag%search proc~search->proc~parse program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~parse proc~get_content xml_tag%get_content proc~get_content->proc~search proc~content xml_file%content proc~content->proc~get_content Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine get ( self , source ) !< Get the tag content and attributes from source after tag_name and attributes names have been set. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. call self % get_value ( source = source ) call self % get_attributes ( source = source ) ! call self%get_nested() endsubroutine get","tags":"","url":"proc/get.html"},{"title":"get_attributes – FoXy","text":"private elemental subroutine get_attributes(self, source) Get the attributes values from source after tag_name and attributes names have been set. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. Called by proc~~get_attributes~~CalledByGraph proc~get_attributes xml_tag%get_attributes proc~get xml_tag%get proc~get->proc~get_attributes proc~parse xml_tag%parse proc~parse->proc~get proc~search xml_tag%search proc~search->proc~parse program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~parse proc~get_content xml_tag%get_content proc~get_content->proc~search proc~content xml_file%content proc~content->proc~get_content Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine get_attributes ( self , source ) !< Get the attributes values from source after tag_name and attributes names have been set. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. integer :: a !< Counter. integer :: c1 !< Counter. integer :: c2 !< Counter. if ( index ( string = source , substring = '<' // self % tag_name ) > 0 ) then if ( self % attributes_number > 0 ) then ! parsing attributes do a = 1 , self % attributes_number c1 = index ( string = source , substring = self % attribute ( 1 , a ) // '=\"' ) + self % attribute ( 1 , a )% len () + 2 if ( c1 > self % attribute ( 1 , a )% len () + 2 ) then c2 = index ( string = source ( c1 :), substring = '\"' ) if ( c2 > 0 ) then self % attribute ( 2 , a ) = source ( c1 : c1 + c2 - 2 ) else call self % attribute ( 2 , a )% free endif else call self % attribute ( 2 , a )% free endif enddo endif endif endsubroutine get_attributes","tags":"","url":"proc/get_attributes.html"},{"title":"get_value – FoXy","text":"private elemental subroutine get_value(self, source) Get the tag value from source after tag_name has been set. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. Called by proc~~get_value~~CalledByGraph proc~get_value xml_tag%get_value proc~get xml_tag%get proc~get->proc~get_value proc~parse xml_tag%parse proc~parse->proc~get proc~search xml_tag%search proc~search->proc~parse program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~parse proc~get_content xml_tag%get_content proc~get_content->proc~search proc~content xml_file%content proc~content->proc~get_content Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine get_value ( self , source ) !< Get the tag value from source after tag_name has been set. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. integer :: c1 !< Counter. integer :: c2 !< Counter. call self % tag_content % free self % is_self_closing = . false . if ( index ( string = source , substring = '<' // self % tag_name ) > 0 ) then c2 = index ( string = source , substring = '</' // self % tag_name // '>' ) if ( c2 > 0 ) then ! parsing tag value c1 = index ( string = source , substring = '>' ) if ( c1 + 1 < c2 - 1 ) self % tag_content = source ( c1 + 1 : c2 - 1 ) else self % is_self_closing = . true . endif endif endsubroutine get_value","tags":"","url":"proc/get_value.html"},{"title":"parse_attributes_names – FoXy","text":"private elemental subroutine parse_attributes_names(self, source) Parse the tag attributes names contained into a string. Valid syntax is:\n+ att1=\"att1 val\" att2=\"att2 val\"... Note Inside the attributes value the symbols < and > are not allowed. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. Calls proc~~parse_attributes_names~~CallsGraph proc~parse_attributes_names xml_tag%parse_attributes_names proc~alloc_attributes xml_tag%alloc_attributes proc~parse_attributes_names->proc~alloc_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_attributes_names~~CalledByGraph proc~parse_attributes_names xml_tag%parse_attributes_names proc~parse xml_tag%parse proc~parse->proc~parse_attributes_names proc~search xml_tag%search proc~search->proc~parse program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->proc~parse proc~get_content xml_tag%get_content proc~get_content->proc~search proc~content xml_file%content proc~content->proc~get_content Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine parse_attributes_names ( self , source ) !< Parse the tag attributes names contained into a string. !< !< Valid syntax is: !< + `att1=\"att1 val\" att2=\"att2 val\"...` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. character ( len = :), allocatable :: att !< Dummy string for parsing file. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: Na !< Counter. Na = 0 c = 1 att_count : do while ( c <= len ( source )) if ( source ( c : c ) == '=' ) Na = Na + 1 c = c + 1 enddo att_count if ( Na > 0 ) then call self % alloc_attributes ( Na = Na ) c = index ( string = source , substring = ' ' ) att = source ( c :) c = 1 a = 1 att_search : do while ( c <= len ( att )) if ( att ( c : c ) == '=' ) then s = max ( 0 , index ( string = att , substring = ' ' )) self % attribute ( 1 , a ) = trim ( adjustl ( att ( s + 1 : c - 1 ))) att = att ( c + 1 :) c = 1 a = a + 1 endif c = c + 1 enddo att_search endif endsubroutine parse_attributes_names","tags":"","url":"proc/parse_attributes_names.html"},{"title":"search – FoXy","text":"private elemental subroutine search(self, tag_name, source, tstart, tend) Search tag named tag_name into a string and, in case it is found, store into self. Note If tag_name is not found, self is returned empty. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: tag_name Searched tag name. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the source. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the source. Calls proc~~search~~CallsGraph proc~search xml_tag%search is_allocated is_allocated proc~search->is_allocated proc~parse xml_tag%parse proc~search->proc~parse proc~parse->is_allocated proc~get xml_tag%get proc~parse->proc~get proc~parse_attributes_names xml_tag%parse_attributes_names proc~parse->proc~parse_attributes_names proc~parse_tag_name xml_tag%parse_tag_name proc~parse->proc~parse_tag_name proc~get_attributes xml_tag%get_attributes proc~get->proc~get_attributes proc~get_value xml_tag%get_value proc~get->proc~get_value proc~alloc_attributes xml_tag%alloc_attributes proc~parse_attributes_names->proc~alloc_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~search~~CalledByGraph proc~search xml_tag%search proc~get_content xml_tag%get_content proc~get_content->proc~search proc~content xml_file%content proc~content->proc~get_content Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine search ( self , tag_name , source , tstart , tend ) !< Search tag named *tag_name* into a string and, in case it is found, store into self. !< !< @note If *tag_name* is not found, self is returned empty. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: tag_name !< Searched tag name. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the source. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the source. type ( xml_tag ) :: tag !< Dummy XML tag. integer ( I4P ) :: tstart_ !< Starting index of tag inside the source, local variable. integer ( I4P ) :: tend_ !< Ending index of tag inside the source, local variable. logical :: found !< Flag for inquiring search result. integer ( I4P ) :: tstart_c !< Starting index of tag inside the current slice of source. integer ( I4P ) :: tend_c !< Starting index of tag inside the current slice of source. integer ( I4P ) :: i call self % free self % tag_name = tag_name tstart_ = 1 tend_ = 0 found = . false . tstart_c = 0 tend_c = 0 tag_search : do call tag % parse ( source = source ( tend_ + 1 :), tstart = tstart_c , tend = tend_c ) tstart_ = tstart_ + tend_ tend_ = tend_ + tend_c if ( tstart_c == 0. and . tend_c == 0 ) then exit tag_search ! no tag found else if ( tag % tag_name % is_allocated ()) then if ( tag % tag_name == self % tag_name ) found = . true . endif endif if ( found ) exit tag_search enddo tag_search if ( found ) then self = tag else call self % free endif if ( present ( tstart )) tstart = tstart_ if ( present ( tend )) tend = tend_ endsubroutine search","tags":"","url":"proc/search.html"},{"title":"assign_tag – FoXy","text":"private elemental subroutine assign_tag(lhs, rhs) Assignment between two tags. Type Bound xml_tag Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: lhs Left hand side. type( xml_tag ), intent(in) :: rhs Right hand side. Calls proc~~assign_tag~~CallsGraph proc~assign_tag xml_tag%assign_tag is_allocated is_allocated proc~assign_tag->is_allocated Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine assign_tag ( lhs , rhs ) !< Assignment between two tags. class ( xml_tag ), intent ( inout ) :: lhs !< Left hand side. type ( xml_tag ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: a !< Counter. call lhs % free if ( rhs % tag_name % is_allocated ()) lhs % tag_name = rhs % tag_name if ( rhs % tag_content % is_allocated ()) lhs % tag_content = rhs % tag_content lhs % pos = rhs % pos if ( rhs % attributes_number > 0 ) then allocate ( lhs % attribute ( 1 : 2 , 1 : rhs % attributes_number )) do a = 1 , rhs % attributes_number lhs % attribute ( 1 : 2 , a ) = rhs % attribute ( 1 : 2 , a ) enddo endif lhs % attributes_number = rhs % attributes_number lhs % indent = rhs % indent lhs % is_self_closing = rhs % is_self_closing lhs % level = rhs % level lhs % id = rhs % id lhs % parent_id = rhs % parent_id lhs % children_number = rhs % children_number if ( allocated ( rhs % child_ID )) lhs % child_ID = rhs % child_ID endsubroutine assign_tag","tags":"","url":"proc/assign_tag.html"},{"title":"finalize – FoXy","text":"private elemental subroutine finalize(tag) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( xml_tag ), intent(inout) :: tag XML tag. Source Code elemental subroutine finalize ( tag ) !< Free dynamic memory when finalizing. type ( xml_tag ), intent ( inout ) :: tag !< XML tag. call tag % free endsubroutine finalize","tags":"","url":"proc/finalize.html"},{"title":"xml_tag – FoXy","text":"public interface xml_tag Overload xml_tag with creator procedures. Calls interface~~xml_tag~~CallsGraph interface~xml_tag xml_tag proc~create_tag_flat create_tag_flat interface~xml_tag->proc~create_tag_flat proc~create_tag_nested create_tag_nested interface~xml_tag->proc~create_tag_nested proc~set xml_tag%set proc~create_tag_flat->proc~set proc~create_tag_nested->proc~set proc~stringify xml_tag%stringify proc~create_tag_nested->proc~stringify proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function create_tag_flat (name, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, content, indent, is_content_indented, is_self_closing, id, level, parent_id, attributes_stream_alloc, content_alloc) result(tag) Return an instance of xml tag. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Tag name. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list as single stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. character(len=*), intent(in), optional :: content Tag value. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate content indentation. logical, intent(in), optional :: is_self_closing The tag is self closing. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Return Value type( xml_tag ) XML tag. private pure function create_tag_nested (name, content, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, indent, is_content_indented, id, level, parent_id, attributes_stream_alloc, content_alloc) result(tag) Return an instance of xml tag with value being a nested tag. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Tag name. type( xml_tag ), intent(in) :: content Tag value as nested tag.. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list as single stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate value indentation. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Return Value type( xml_tag ) XML tag.","tags":"","url":"interface/xml_tag.html"},{"title":"content – FoXy","text":"private pure function content(self, name) Return tag content of tag named name . Note If there is no value, the tag_content string is returned empty, but allocated. Type Bound xml_file Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. character(len=*), intent(in) :: name Tag name. Return Value character(len=:), allocatable Tag content. Calls proc~~content~~CallsGraph proc~content xml_file%content proc~get_content xml_tag%get_content proc~content->proc~get_content chars chars proc~get_content->chars is_allocated is_allocated proc~get_content->is_allocated proc~search xml_tag%search proc~get_content->proc~search proc~search->is_allocated proc~parse xml_tag%parse proc~search->proc~parse proc~parse->is_allocated proc~get xml_tag%get proc~parse->proc~get proc~parse_attributes_names xml_tag%parse_attributes_names proc~parse->proc~parse_attributes_names proc~parse_tag_name xml_tag%parse_tag_name proc~parse->proc~parse_tag_name proc~get_attributes xml_tag%get_attributes proc~get->proc~get_attributes proc~get_value xml_tag%get_value proc~get->proc~get_value proc~alloc_attributes xml_tag%alloc_attributes proc~parse_attributes_names->proc~alloc_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function content ( self , name ) !< Return tag content of tag named *name*. !< !< @note If there is no value, the *tag_content* string is returned empty, but allocated. class ( xml_file ), intent ( in ) :: self !< XML file. character ( * ), intent ( in ) :: name !< Tag name. character ( len = :), allocatable :: content !< Tag content. integer ( I4P ) :: t !< Counter. if ( allocated ( content )) deallocate ( content ) if ( self % nt > 0 ) then do t = 1 , self % nt call self % tag ( t )% get_content ( name = name , content = content ) if ( allocated ( content )) exit enddo endif if (. not . allocated ( content )) content = '' endfunction content","tags":"","url":"proc/content.html"},{"title":"stringify – FoXy","text":"private pure function stringify(self, linearize) result(string) Convert the whole file data into a string. Type Bound xml_file Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. logical, intent(in), optional :: linearize Return a \"linearized\" string of tags without the XML hieararchy. Return Value character(len=:), allocatable Output string containing the whole xml file. Calls proc~~stringify~2~~CallsGraph proc~stringify~2 xml_file%stringify proc~stringify xml_tag%stringify proc~stringify~2->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify~2->proc~stringify_recursive chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~stringify~2~~CalledByGraph proc~stringify~2 xml_file%stringify program~foxy_test_add_tag foxy_test_add_tag program~foxy_test_add_tag->proc~stringify~2 program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~stringify~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~stringify~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~stringify~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~stringify~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~stringify~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function stringify ( self , linearize ) result ( string ) !< Convert the whole file data into a string. class ( xml_file ), intent ( in ) :: self !< XML file. logical , intent ( in ), optional :: linearize !< Return a \"linearized\" string of tags without the XML hieararchy. logical :: linearize_ !< Linearize sentinel, local var. character ( len = :), allocatable :: string !< Output string containing the whole xml file. character ( len = :), allocatable :: tag_string !< Output string containing the current tag. integer ( I4P ) :: t !< Counter. logical , allocatable :: is_done (:) !< List of stringified tags. linearize_ = . false . ; if ( present ( linearize )) linearize_ = linearize string = '' if ( linearize_ ) then if ( self % nt > 0 ) then do t = 1 , self % nt string = string // self % tag ( t )% stringify ( linearize = . true .) // new_line ( 'a' ) enddo endif else if ( self % nt > 0 ) then allocate ( is_done ( self % nt )) ; is_done = . false . do t = 1 , self % nt if ( is_done ( t )) cycle if ( self % tag ( t )% children_number > 0 ) then tag_string = '' call self % stringify_recursive ( tag = self % tag ( t ), is_done = is_done , tag_string = tag_string ) if ( tag_string ( 1 : 1 ) == new_line ( 'a' )) tag_string = tag_string ( 2 :) else tag_string = self % tag ( t )% stringify ( is_indented = . true .) endif string = string // tag_string // new_line ( 'a' ) is_done ( t ) = . true . enddo endif endif if ( string ( len ( string ): len ( string )) == new_line ( 'a' )) string = string (: len ( string ) - 1 ) endfunction stringify","tags":"","url":"proc/stringify~2.html"},{"title":"load_file_as_stream – FoXy","text":"private  function load_file_as_stream(filename, delimiter_start, delimiter_end, fast_read, iostat, iomsg) result(stream) Load file contents and store as single characters stream. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File name. character(len=*), intent(in), optional :: delimiter_start Delimiter from which start the stream. character(len=*), intent(in), optional :: delimiter_end Delimiter to which end the stream. logical, intent(in), optional :: fast_read Flag for activating efficient reading with one single read. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Return Value character(len=:), allocatable Output string containing the file data as a single stream. Called by proc~~load_file_as_stream~~CalledByGraph proc~load_file_as_stream load_file_as_stream proc~parse~2 xml_file%parse proc~parse~2->proc~load_file_as_stream program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function load_file_as_stream ( filename , delimiter_start , delimiter_end , fast_read , iostat , iomsg ) result ( stream ) !< Load file contents and store as single characters stream. character ( * ), intent ( in ) :: filename !< File name. character ( * ), optional , intent ( in ) :: delimiter_start !< Delimiter from which start the stream. character ( * ), optional , intent ( in ) :: delimiter_end !< Delimiter to which end the stream. logical , optional , intent ( in ) :: fast_read !< Flag for activating efficient reading with one single read. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: stream !< Output string containing the file data as a single stream. logical :: is_file !< Flag for inquiring the presence of the file. integer ( I4P ) :: unit !< Unit file. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< IO error message. character ( 1 ) :: c1 !< Single character. character ( len = :), allocatable :: string !< Dummy string. logical :: cstart !< Flag for stream capturing trigging. logical :: cend !< Flag for stream capturing trigging. logical :: fast !< Flag for activating efficient reading with one single read. integer ( I4P ) :: filesize !< Size of the file for fast reading. fast = . false . ; if ( present ( fast_read )) fast = fast_read ! inquire file existance inquire ( file = adjustl ( trim ( filename )), exist = is_file , iostat = iostatd , iomsg = iomsgd ) if (. not . is_file ) then if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return endif ! open file open ( newunit = unit , file = adjustl ( trim ( filename )), access = 'STREAM' , form = 'UNFORMATTED' , iostat = iostatd , iomsg = iomsgd ) if ( iostatd /= 0 ) then if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return endif ! loadg data stream = '' if ( present ( delimiter_start ). and . present ( delimiter_end )) then ! load only data inside delimiter_start and delimiter_end string = '' Main_Read_Loop : do read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 if ( c1 == delimiter_start ( 1 : 1 )) then cstart = . true . string = c1 Start_Read_Loop : do while ( len ( string ) < len ( delimiter_start )) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 string = string // c1 if (. not .( index ( string = delimiter_start , substring = string ) > 0 )) then cstart = . false . exit Start_Read_Loop endif enddo Start_Read_Loop if ( cstart ) then cend = . false . stream = string do while (. not . cend ) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 if ( c1 == delimiter_end ( 1 : 1 )) then ! maybe the end string = c1 End_Read_Loop : do while ( len ( string ) < len ( delimiter_end )) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 string = string // c1 if (. not .( index ( string = delimiter_end , substring = string ) > 0 )) then stream = stream // string exit End_Read_Loop elseif ( len ( string ) == len ( delimiter_end )) then cend = . true . stream = stream // string exit Main_Read_Loop endif enddo End_Read_Loop else stream = stream // c1 endif enddo endif endif enddo Main_Read_Loop else ! load all data if ( fast ) then ! load fast inquire ( file = adjustl ( trim ( filename )), size = filesize , iostat = iostatd , iomsg = iomsgd ) if ( iostatd == 0 ) then if ( allocated ( stream )) deallocate ( stream ) allocate ( character ( len = filesize ) :: stream ) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) stream endif else ! load slow, one character loop Read_Loop : do read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 stream = stream // c1 enddo Read_Loop endif endif 10 close ( unit ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endfunction load_file_as_stream","tags":"","url":"proc/load_file_as_stream.html"},{"title":"add_tag – FoXy","text":"private elemental subroutine add_tag(self, tag) Add tag to XML file. Type Bound xml_file Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. type( xml_tag ), intent(in) :: tag XML tag. Called by proc~~add_tag~~CalledByGraph proc~add_tag xml_file%add_tag proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~add_tag program~foxy_test_add_tag foxy_test_add_tag program~foxy_test_add_tag->proc~add_tag proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine add_tag ( self , tag ) !< Add tag to XML file. class ( xml_file ), intent ( inout ) :: self !< XML file. type ( xml_tag ), intent ( in ) :: tag !< XML tag. type ( xml_tag ), allocatable :: tag_new (:) !< New (extended) tags array. if ( self % nt > 0_I4P ) then allocate ( tag_new ( 1 : self % nt + 1 )) tag_new ( 1 : self % nt ) = self % tag ( 1 : self % nt ) tag_new ( self % nt + 1 ) = tag else allocate ( tag_new ( 1 : 1 )) tag_new ( 1 ) = tag endif call move_alloc ( from = tag_new , to = self % tag ) self % nt = self % nt + 1 endsubroutine add_tag","tags":"","url":"proc/add_tag.html"},{"title":"delete_tag – FoXy","text":"private elemental subroutine delete_tag(self, name) Delete tag from XML file. Type Bound xml_file Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. character(len=*), intent(in) :: name XML tag name. Calls proc~~delete_tag~~CallsGraph proc~delete_tag xml_file%delete_tag proc~name xml_tag%name proc~delete_tag->proc~name chars chars proc~name->chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~delete_tag~~CalledByGraph proc~delete_tag xml_file%delete_tag program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~delete_tag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine delete_tag ( self , name ) !< Delete tag from XML file. class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), intent ( in ) :: name !< XML tag name. type ( xml_tag ), allocatable :: tag_new (:) !< New (extended) tags array. integer ( I4P ) :: t !< Counter. if ( self % nt > 0_I4P ) then do t = 1 , self % nt if ( name == self % tag ( t )% name ()) then allocate ( tag_new ( 1 : self % nt - 1 )) if ( t == 1 ) then tag_new ( t :) = self % tag ( t + 1 :) elseif ( t == self % nt ) then tag_new (: t - 1 ) = self % tag (: t - 1 ) else tag_new (: t - 1 ) = self % tag (: t - 1 ) tag_new ( t :) = self % tag ( t + 1 :) endif call move_alloc ( from = tag_new , to = self % tag ) self % nt = self % nt - 1 exit endif enddo endif endsubroutine delete_tag","tags":"","url":"proc/delete_tag.html"},{"title":"free – FoXy","text":"private elemental subroutine free(self) Free dynamic memory. Type Bound xml_file Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. Source Code elemental subroutine free ( self ) !< Free dynamic memory. class ( xml_file ), intent ( inout ) :: self !< XML file. if ( allocated ( self % tag )) then call self % tag % free deallocate ( self % tag ) endif self % nt = 0_I4P endsubroutine free","tags":"","url":"proc/free~2.html"},{"title":"parse – FoXy","text":"private  subroutine parse(self, string, filename) Parse xml data from string or file.\nXML data is linearized, a DOM structured is used. Note Self data are free before trying to parse new xml data: all previously parsed data are lost. Type Bound xml_file Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. character(len=*), intent(in), optional :: string String containing xml data. character(len=*), intent(in), optional :: filename File name containing xml data. Calls proc~~parse~2~~CallsGraph proc~parse~2 xml_file%parse proc~load_file_as_stream load_file_as_stream proc~parse~2->proc~load_file_as_stream proc~parse_from_string xml_file%parse_from_string proc~parse~2->proc~parse_from_string proc~add_child xml_file%add_child proc~parse_from_string->proc~add_child proc~add_tag xml_file%add_tag proc~parse_from_string->proc~add_tag proc~get_tag_content get_tag_content proc~parse_from_string->proc~get_tag_content proc~parse_tag_name~2 parse_tag_name proc~parse_from_string->proc~parse_tag_name~2 proc~set xml_tag%set proc~parse_from_string->proc~set proc~add_child_id xml_tag%add_child_id proc~add_child->proc~add_child_id proc~find_matching_end_tag find_matching_end_tag proc~get_tag_content->proc~find_matching_end_tag proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse~2~~CalledByGraph proc~parse~2 xml_file%parse program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine parse ( self , string , filename ) !< Parse xml data from string or file. !< XML data is linearized, a DOM structured is used. !< !< @note Self data are free before trying to parse new xml data: all previously parsed data are lost. class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), optional , intent ( in ) :: string !< String containing xml data. character ( * ), optional , intent ( in ) :: filename !< File name containing xml data. character ( len = :), allocatable :: source !< String containing xml data. call self % free if ( present ( string )) then call self % parse_from_string ( source_string = string ) elseif ( present ( filename )) then source = load_file_as_stream ( filename = filename , fast_read = . true .) call self % parse_from_string ( source_string = source ) endif endsubroutine parse","tags":"","url":"proc/parse~2.html"},{"title":"add_child – FoXy","text":"private pure subroutine add_child(self, parent_id, child_id) Add child ID to tag children list. Type Bound xml_file Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file handler. integer(kind=I4P), intent(in) :: parent_id Parent ID. integer(kind=I4P), intent(in) :: child_id Child ID. Calls proc~~add_child~~CallsGraph proc~add_child xml_file%add_child proc~add_child_id xml_tag%add_child_id proc~add_child->proc~add_child_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_child~~CalledByGraph proc~add_child xml_file%add_child proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~add_child proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine add_child ( self , parent_id , child_id ) !< Add child ID to tag children list. class ( xml_file ), intent ( inout ) :: self !< XML file handler. integer ( I4P ), intent ( in ) :: child_id !< Child ID. integer ( I4P ), intent ( in ) :: parent_id !< Parent ID. if ( parent_id > 0 . and . parent_id <= self % nt ) call self % tag ( parent_id )% add_child_id ( child_id = child_id ) endsubroutine add_child","tags":"","url":"proc/add_child.html"},{"title":"parse_from_string – FoXy","text":"private pure subroutine parse_from_string(self, source_string) Parse xml data from a chunk of source string (file stringified for IO on device). Type Bound xml_file Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file handler. character(len=*), intent(in) :: source_string String containing xml data. Calls proc~~parse_from_string~~CallsGraph proc~parse_from_string xml_file%parse_from_string proc~add_child xml_file%add_child proc~parse_from_string->proc~add_child proc~add_tag xml_file%add_tag proc~parse_from_string->proc~add_tag proc~get_tag_content get_tag_content proc~parse_from_string->proc~get_tag_content proc~parse_tag_name~2 parse_tag_name proc~parse_from_string->proc~parse_tag_name~2 proc~set xml_tag%set proc~parse_from_string->proc~set proc~add_child_id xml_tag%add_child_id proc~add_child->proc~add_child_id proc~find_matching_end_tag find_matching_end_tag proc~get_tag_content->proc~find_matching_end_tag proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~parse_from_string~~CalledByGraph proc~parse_from_string xml_file%parse_from_string proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine parse_from_string ( self , source_string ) !< Parse xml data from a chunk of source string (file stringified for IO on device). class ( xml_file ), intent ( inout ) :: self !< XML file handler. character ( * ), intent ( in ) :: source_string !< String containing xml data. integer ( I4P ) :: pos , start_pos , end_pos , end_content_pos !< Position indexes. character (:), allocatable :: tag_name !< Tag name buffer. character (:), allocatable :: attributes_str !< Tag attributes string buffer. character (:), allocatable :: tag_content !< Tag content string buffer. integer ( I4P ) :: current_level !< Nesting level counter. logical :: is_closing_tag !< Sentinel for closing tag. logical :: is_self_closing !< Sentinel for self closing tag. type ( xml_tag ) :: tag !< XML tag handler. integer ( I4P ) :: parent_id !< Uniq parent tag ID. integer ( I4P ), allocatable :: parent_stack (:) !< Stack of parents ID. call self % free pos = 1_I4P current_level = 0_I4P allocate ( parent_stack ( 1 )) parent_stack = 0_I4P do while ( pos <= len_trim ( source_string )) ! next tag start start_pos = index ( source_string ( pos :), '<' ) if ( start_pos == 0 ) exit start_pos = pos + start_pos - 1 ! skip comment, XML header if ( start_pos + 3 <= len_trim ( source_string )) then if ( source_string ( start_pos : start_pos + 3 ) == '<!--' . or . source_string ( start_pos : start_pos + 1 ) == '<?' ) then end_pos = index ( source_string ( start_pos + 1 :), '>' ) if ( end_pos == 0 ) exit pos = start_pos + end_pos + 1 cycle endif endif ! close current tag end_pos = index ( source_string ( start_pos :), '>' ) if ( end_pos == 0 ) exit end_pos = start_pos + end_pos - 1 ! parse tag call parse_tag_name ( tag_str = source_string ( start_pos : end_pos ), & tag_name = tag_name , & attributes_str = attributes_str , & is_closing = is_closing_tag , & is_self_closing = is_self_closing ) if ( allocated ( tag_name )) then if ( is_closing_tag ) then current_level = current_level - 1 else ! add new tag to XML tags list call tag % free call self % add_tag ( tag = tag ) current_level = current_level + 1 ! get parent/child id if ( current_level > 1 ) then if ( parent_stack ( current_level - 1 ) > 0 ) then parent_id = parent_stack ( current_level - 1 ) call self % add_child ( parent_id = parent_stack ( current_level - 1 ), child_id = self % nt ) endif elseif ( current_level == 1 ) then parent_id = 0_I4P endif ! parent_stack(current_level) = self%nt if ( current_level == 1 ) then parent_stack ( 1 ) = self % nt else if ( current_level > 1 ) parent_stack = [ parent_stack ( 1 : current_level - 1 ), self % nt ] endif end_content_pos = - 1 ! initialize position for self closing tag if (. not . is_self_closing ) then ! get tag content call get_tag_content ( source = source_string , tag_name = tag_name , start_pos = end_pos + 1 , content = tag_content , & end_pos = end_content_pos ) endif call self % tag ( self % nt )% set ( name = tag_name , & sanitize_attributes_value = . true ., & pos = [ start_pos , end_pos , end_content_pos ], & indent = ( current_level - 1 ) * 2 , & is_self_closing = is_self_closing , & id = self % nt , & level = current_level , & parent_id = parent_id , & attributes_stream_alloc = attributes_str , & content_alloc = tag_content ) if ( is_self_closing ) current_level = current_level - 1 endif endif pos = end_pos + 1 enddo endsubroutine parse_from_string","tags":"","url":"proc/parse_from_string.html"},{"title":"stringify_recursive – FoXy","text":"private pure recursive subroutine stringify_recursive(self, tag, is_done, tag_string) Convert recursively tags with children into a string. Type Bound xml_file Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. type( xml_tag ), intent(in) :: tag XML tag with children. logical, intent(inout) :: is_done (:) List of stringified tags. character(len=:), intent(inout), allocatable :: tag_string Output string containing the current tag. Calls proc~~stringify_recursive~~CallsGraph proc~stringify_recursive xml_file%stringify_recursive proc~stringify_recursive->proc~stringify_recursive proc~stringify xml_tag%stringify proc~stringify_recursive->proc~stringify chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~stringify_recursive~~CalledByGraph proc~stringify_recursive xml_file%stringify_recursive proc~stringify_recursive->proc~stringify_recursive proc~stringify~2 xml_file%stringify proc~stringify~2->proc~stringify_recursive program~foxy_test_add_tag foxy_test_add_tag program~foxy_test_add_tag->proc~stringify~2 program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~stringify~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~stringify~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~stringify~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~stringify~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~stringify~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code recursive pure subroutine stringify_recursive ( self , tag , is_done , tag_string ) !< Convert recursively tags with children into a string. class ( xml_file ), intent ( in ) :: self !< XML file. type ( xml_tag ), intent ( in ) :: tag !< XML tag with children. logical , intent ( inout ) :: is_done (:) !< List of stringified tags. character ( len = :), allocatable , intent ( inout ) :: tag_string !< Output string containing the current tag. integer ( I4P ) :: t !< Counter. if ( tag % children_number > 0 ) then tag_string = tag_string // new_line ( 'a' ) // tag % stringify ( is_indented = . true ., only_start = . true .) do t = 1 , tag % children_number call self % stringify_recursive ( tag = self % tag ( tag % child_id ( t )), is_done = is_done , tag_string = tag_string ) is_done ( tag % child_id ( t )) = . true . enddo tag_string = tag_string // new_line ( 'a' ) // tag % stringify ( is_indented = . true ., only_end = . true .) else tag_string = tag_string // new_line ( 'a' ) // tag % stringify ( is_indented = . true .) endif endsubroutine stringify_recursive","tags":"","url":"proc/stringify_recursive.html"},{"title":"finalize – FoXy","text":"private  subroutine finalize(self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( xml_file ), intent(inout) :: self XML file. Source Code subroutine finalize ( self ) !< Free dynamic memory when finalizing. type ( xml_file ), intent ( inout ) :: self !< XML file. call self % free endsubroutine finalize","tags":"","url":"proc/finalize~2.html"},{"title":"find_matching_end_tag – FoXy","text":"private pure subroutine find_matching_end_tag(source, start_pos, tag_name, end_pos) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source Source containing tag content. integer(kind=I4P), intent(in) :: start_pos Start tag content position. character(len=*), intent(in) :: tag_name Tag name. integer(kind=I4P), intent(out) :: end_pos End tag position. Called by proc~~find_matching_end_tag~~CalledByGraph proc~find_matching_end_tag find_matching_end_tag proc~get_tag_content get_tag_content proc~get_tag_content->proc~find_matching_end_tag proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~get_tag_content proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine find_matching_end_tag ( source , start_pos , tag_name , end_pos ) character ( * ), intent ( in ) :: source !< Source containing tag content. character ( * ), intent ( in ) :: tag_name !< Tag name. integer ( I4P ), intent ( in ) :: start_pos !< Start tag content position. integer ( I4P ), intent ( out ) :: end_pos !< End tag position. character (:), allocatable :: open_tag !< Open tag. character (:), allocatable :: end_tag !< End tag. integer ( I4P ) :: pos , pos_tmp ( 2 ) !< Position counter. integer ( I4P ) :: tag_count !< Tags counter. open_tag = '<' // trim ( tag_name ) end_tag = '</' // trim ( tag_name ) // '>' tag_count = 1 pos = start_pos end_pos = 0 ! search for next open tag with the same name pos_tmp ( 1 ) = index ( source ( pos :), trim ( open_tag )) ! relative position pos_tmp ( 2 ) = index ( source ( pos :), trim ( end_tag )) ! relative position if ( pos_tmp ( 1 ) < pos_tmp ( 2 )) then ! there are nested tags with the same name do while ( pos <= len_trim ( source ) . and . tag_count > 0 ) ! search next tag with the same name pos_tmp ( 1 ) = index ( source ( pos :), trim ( open_tag )) ! relative position if ( pos_tmp ( 1 ) > 0 ) then pos_tmp ( 1 ) = pos + pos_tmp ( 1 ) - 1 ! absolute position ! check if it is open tag if ( pos_tmp ( 1 ) + len_trim ( open_tag ) <= len_trim ( source )) then if ( source ( pos_tmp ( 1 ) + len_trim ( open_tag ): pos_tmp ( 1 ) + len_trim ( open_tag )) == '>' . or . & source ( pos_tmp ( 1 ) + len_trim ( open_tag ): pos_tmp ( 1 ) + len_trim ( open_tag )) == ' ' ) then ! open tag tag_count = tag_count + 1 ! update tags counter pos = pos_tmp ( 1 ) + len_trim ( open_tag ) ! update position after tag cycle endif endif endif ! search next end tag pos_tmp ( 1 ) = index ( source ( pos :), trim ( end_tag )) ! relative position if ( pos_tmp ( 1 ) > 0 ) then pos_tmp ( 1 ) = pos + pos_tmp ( 1 ) - 1 ! absolute position tag_count = tag_count - 1 ! update tags counter if ( tag_count == 0 ) then ! found matching end tag end_pos = pos_tmp ( 1 ) return endif pos = pos_tmp ( 1 ) + len_trim ( end_tag ) ! update position after tag else exit endif enddo elseif ( pos_tmp ( 2 ) < 0 ) then ! there is a problem else end_pos = pos + pos_tmp ( 2 ) - 1 ! absolute position endif endsubroutine find_matching_end_tag","tags":"","url":"proc/find_matching_end_tag.html"},{"title":"get_tag_content – FoXy","text":"private pure subroutine get_tag_content(source, tag_name, start_pos, content, end_pos) Get tag content. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source Source containing tag content. character(len=*), intent(in) :: tag_name Tag name. integer, intent(in) :: start_pos Start tag content position. character(len=:), intent(out), allocatable :: content Extracted tag content. integer(kind=I4P), intent(out), optional :: end_pos End tag content position. Calls proc~~get_tag_content~~CallsGraph proc~get_tag_content get_tag_content proc~find_matching_end_tag find_matching_end_tag proc~get_tag_content->proc~find_matching_end_tag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_tag_content~~CalledByGraph proc~get_tag_content get_tag_content proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~get_tag_content proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine get_tag_content ( source , tag_name , start_pos , content , end_pos ) !< Get tag content. character ( * ), intent ( in ) :: source !< Source containing tag content. character ( * ), intent ( in ) :: tag_name !< Tag name. integer , intent ( in ) :: start_pos !< Start tag content position. character (:), allocatable , intent ( out ) :: content !< Extracted tag content. integer ( I4P ), intent ( out ), optional :: end_pos !< End tag content position. character (:), allocatable :: end_tag !< End tag. integer ( I4P ) :: end_pos_ !< End tag content position, local var. integer ( I4P ) :: next_pos !< Next tag start position. character (:), allocatable :: temp_content !< Buffer. end_tag = '</' // trim ( tag_name ) // '>' content = '' call find_matching_end_tag ( source = source , start_pos = start_pos , tag_name = tag_name , end_pos = end_pos_ ) if ( present ( end_pos )) end_pos = end_pos_ if ( end_pos_ > start_pos ) then ! search first nested tag, if any next_pos = index ( source ( start_pos : end_pos_ - 1 ), '<' ) if ( next_pos > 0 ) then ! find nested tag next_pos = start_pos + next_pos - 2 temp_content = trim ( adjustl ( source ( start_pos : next_pos ))) if ( len ( temp_content ) > 0 ) content = temp_content else ! no nested tag temp_content = trim ( adjustl ( source ( start_pos : end_pos_ - 1 ))) if ( len ( temp_content ) > 0 ) content = temp_content endif endif endsubroutine get_tag_content","tags":"","url":"proc/get_tag_content.html"},{"title":"parse_tag_name – FoXy","text":"private pure subroutine parse_tag_name(tag_str, tag_name, attributes_str, is_closing, is_self_closing) Parse current tag, only name and attributes. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tag_str Tag string. character(len=:), intent(out), allocatable :: tag_name Parsed tag name. character(len=:), intent(out), allocatable :: attributes_str Parsed attributes list. logical, intent(out) :: is_closing Sentinel for closing tag. logical, intent(out) :: is_self_closing Sentinel for self closing tag. Called by proc~~parse_tag_name~2~~CalledByGraph proc~parse_tag_name~2 parse_tag_name proc~parse_from_string xml_file%parse_from_string proc~parse_from_string->proc~parse_tag_name~2 proc~parse~2 xml_file%parse proc~parse~2->proc~parse_from_string program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->proc~parse~2 program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->proc~parse~2 program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->proc~parse~2 program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->proc~parse~2 program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->proc~parse~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine parse_tag_name ( tag_str , tag_name , attributes_str , is_closing , is_self_closing ) !< Parse current tag, only name and attributes. character ( * ), intent ( in ) :: tag_str !< Tag string. character (:), allocatable , intent ( out ) :: tag_name !< Parsed tag name. character (:), allocatable , intent ( out ) :: attributes_str !< Parsed attributes list. logical , intent ( out ) :: is_closing !< Sentinel for closing tag. logical , intent ( out ) :: is_self_closing !< Sentinel for self closing tag. character (:), allocatable :: clean_tag !< Clean tag string. integer ( I4P ) :: space_pos !< Blank space position. clean_tag = trim ( adjustl ( tag_str )) if ( len ( clean_tag ) < 3 ) return ! trim < and > clean_tag = clean_tag ( 2 : len ( clean_tag ) - 1 ) is_self_closing = ( clean_tag ( len ( clean_tag ): len ( clean_tag )) == '/' ) if ( is_self_closing ) then is_closing = . false . else is_closing = ( clean_tag ( 1 : 1 ) == '/' ) endif if ( is_closing ) clean_tag = clean_tag ( 2 :) if ( is_self_closing ) clean_tag = clean_tag ( 1 : len ( clean_tag ) - 1 ) ! parse name and attributes space_pos = index ( clean_tag , ' ' ) if ( space_pos > 0 ) then tag_name = clean_tag ( 1 : space_pos - 1 ) attributes_str = clean_tag ( space_pos + 1 :) else tag_name = clean_tag endif endsubroutine parse_tag_name","tags":"","url":"proc/parse_tag_name~2.html"},{"title":"foxy – FoXy","text":"FoXy, Fortran XML parser for poor people Uses foxy_xml_file foxy_xml_tag penf module~~foxy~~UsesGraph module~foxy foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~foxy~~UsedByGraph module~foxy foxy program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->module~foxy program~foxy_test_add_tag foxy_test_add_tag program~foxy_test_add_tag->module~foxy program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->module~foxy program~foxy_test_delete_attributes foxy_test_delete_attributes program~foxy_test_delete_attributes->module~foxy program~foxy_test_delete_content foxy_test_delete_content program~foxy_test_delete_content->module~foxy program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->module~foxy program~foxy_test_indent_tag foxy_test_indent_tag program~foxy_test_indent_tag->module~foxy program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->module~foxy program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->module~foxy program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->module~foxy program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->module~foxy Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses.","tags":"","url":"module/foxy.html"},{"title":"foxy_xml_tag – FoXy","text":"FoXy XML tag class. Uses stringifor penf module~~foxy_xml_tag~~UsesGraph module~foxy_xml_tag foxy_xml_tag penf penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~foxy_xml_tag~~UsedByGraph module~foxy_xml_tag foxy_xml_tag module~foxy foxy module~foxy->module~foxy_xml_tag module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_file->module~foxy_xml_tag program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->module~foxy program~foxy_test_add_tag foxy_test_add_tag program~foxy_test_add_tag->module~foxy program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->module~foxy program~foxy_test_delete_attributes foxy_test_delete_attributes program~foxy_test_delete_attributes->module~foxy program~foxy_test_delete_content foxy_test_delete_content program~foxy_test_delete_content->module~foxy program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->module~foxy program~foxy_test_indent_tag foxy_test_indent_tag program~foxy_test_indent_tag->module~foxy program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->module~foxy program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->module~foxy program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->module~foxy program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->module~foxy Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface xml_tag Overload xml_tag with creator procedures. private pure function create_tag_flat (name, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, content, indent, is_content_indented, is_self_closing, id, level, parent_id, attributes_stream_alloc, content_alloc) result(tag) Return an instance of xml tag. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Tag name. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list as single stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. character(len=*), intent(in), optional :: content Tag value. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate content indentation. logical, intent(in), optional :: is_self_closing The tag is self closing. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Return Value type( xml_tag ) XML tag. private pure function create_tag_nested (name, content, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, indent, is_content_indented, id, level, parent_id, attributes_stream_alloc, content_alloc) result(tag) Return an instance of xml tag with value being a nested tag. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Tag name. type( xml_tag ), intent(in) :: content Tag value as nested tag.. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list as single stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate value indentation. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Return Value type( xml_tag ) XML tag. Derived Types type, public :: xml_tag XML tag class. Read more… Components Type Visibility Attributes Name Initial type(string), private :: tag_name Tag name. type(string), private :: tag_content Tag content. integer(kind=I4P), private :: pos (3) = [0_I4P, 0_I4P, 0_I4P] Characters position (in source) indexes (start, content, end). type(string), private, allocatable :: attribute (:,:) Attributes names/values pairs, [1:2, 1:]. integer(kind=I4P), private :: attributes_number = 0_I4P Number of defined attributes. integer(kind=I4P), private :: indent = 0_I4P Number of indent-white-spaces. logical, private :: is_self_closing = .false. Self closing tag flag. integer(kind=I4P), private :: level = 0_I4P Tag hierarchy level. integer(kind=I4P), private :: id = 0_I4P Uniq tag ID. integer(kind=I4P), private :: parent_id = 0_I4P Uniq ID of parent tag. integer(kind=I4P), public :: children_number = 0_I4P Number of children tags. integer(kind=I4P), public, allocatable :: child_id (:) Uniq ID of children tags. Constructor Overload xml_tag with creator procedures. private\n\n                    pure\n                    function create_tag_flat (name, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, content, indent, is_content_indented, is_self_closing, id, level, parent_id, attributes_stream_alloc, content_alloc) Return an instance of xml tag. private\n\n                    pure\n                    function create_tag_nested (name, content, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, indent, is_content_indented, id, level, parent_id, attributes_stream_alloc, content_alloc) Return an instance of xml tag with value being a nested tag. Finalizations Procedures final :: finalize Free dynamic memory when finalizing. Type-Bound Procedures generic, public :: add_attributes => add_single_attribute , add_multiple_attributes , add_stream_attributes Add attributes name/value pairs. procedure, public, pass(self) :: add_child_id Add child ID to children IDs list. procedure, public, pass(self) :: attributes Return attributes name/value pairs as string. generic, public :: delete_attributes => delete_single_attribute , delete_multiple_attributes Delete attributes name/value pairs. procedure, public, pass(self) :: delete_content Delete tag conent. procedure, public, pass(self) :: end_tag Return </tag_name> end tag. procedure, public, pass(self) :: free Free (reset) tag. procedure, public, pass(self) :: get_content Return tag content. procedure, public, pass(self) :: is_attribute_present Return .true. it the queried attribute name is defined. procedure, public, pass(self) :: is_parsed Check is tag is correctly parsed, i.e. its tag_name is allocated. procedure, public, pass(self) :: name Return tag name. procedure, public, pass(self) :: parse Parse the tag contained into a source string. procedure, public, pass(self) :: parse_tag_name Parse the tag name contained into a string. procedure, public, pass(self) :: self_closing_tag Return <tag_name.../> self closing tag. procedure, public, pass(self) :: set Set tag data. procedure, public, pass(self) :: start_tag Return <tag_name...> start tag. procedure, public, pass(self) :: stringify Convert the whole tag into a string. procedure, public, pass(self) :: write => write_tag Write tag to unit file. generic, public :: assignment(=) => assign_tag Assignment operator overloading. procedure, private, pass(self) :: add_single_attribute Add one attribute name/value pair. procedure, private, pass(self) :: add_multiple_attributes Add list of attributes name/value pairs. procedure, private, pass(self) :: add_stream_attributes Add list of attributes name/value pairs passed as stream. procedure, private, pass(self) :: alloc_attributes Allocate (prepare for filling) dynamic memory of attributes. procedure, private, pass(self) :: delete_single_attribute Delete one attribute name/value pair. procedure, private, pass(self) :: delete_multiple_attributes Delete list of attributes name/value pairs. procedure, private, pass(self) :: get Get the tag value and attributes from source. procedure, private, pass(self) :: get_value Get the tag value from source after tag_name has been set. procedure, private, pass(self) :: get_attributes Get the attributes values from source. procedure, private, pass(self) :: parse_attributes_names Parse the tag attributes names contained into a string. procedure, private, pass(self) :: search Search tag named tag_name into a string. procedure, private, pass(lhs) :: assign_tag Assignment between two tags. Functions private pure function create_tag_flat (name, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, content, indent, is_content_indented, is_self_closing, id, level, parent_id, attributes_stream_alloc, content_alloc) result(tag) Return an instance of xml tag. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Tag name. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list as single stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. character(len=*), intent(in), optional :: content Tag value. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate content indentation. logical, intent(in), optional :: is_self_closing The tag is self closing. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Return Value type( xml_tag ) XML tag. private pure function create_tag_nested (name, content, attribute, attributes, attributes_stream, sanitize_attributes_value, pos, indent, is_content_indented, id, level, parent_id, attributes_stream_alloc, content_alloc) result(tag) Return an instance of xml tag with value being a nested tag. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Tag name. type( xml_tag ), intent(in) :: content Tag value as nested tag.. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list as single stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate value indentation. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. Return Value type( xml_tag ) XML tag. private pure function attributes (self) result(att_) Return attributes name/value pairs as string. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value character(len=:), allocatable The attributes string. private pure function end_tag (self, is_indented) result(tag_) Return </tag_name> end tag. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Activate content indentation. Return Value character(len=:), allocatable The end tag string. private pure function is_attribute_present (self, name) result(is_present) Return .true. it the queried attribute name is defined, .false. otherwise. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. character(len=*), intent(in) :: name Attribute name. Return Value logical Inquire result. private elemental function is_parsed (self) Check is tag is correctly parsed, i.e. its tag_name is allocated. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value logical Result of check. private pure function name (self) Return tag name. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value character(len=:), allocatable XML tag name. private pure function self_closing_tag (self, is_indented) result(tag_) Return <tag_name.../> self closing tag. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Flag to check if tag is indented. Return Value character(len=:), allocatable The self closing tag string. private pure function start_tag (self, is_indented) result(tag_) Return <tag_name...> start tag. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Flag to check if tag is indented. Return Value character(len=:), allocatable The start tag string. private pure function stringify (self, is_indented, is_content_indented, only_start, only_content, only_end, linearize) result(stringed) Convert the whole tag into a string. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. logical, intent(in), optional :: is_indented Activate content indentation. logical, intent(in), optional :: is_content_indented Activate content indentation. logical, intent(in), optional :: only_start Write only start tag. logical, intent(in), optional :: only_content Write only content. logical, intent(in), optional :: only_end Write only end tag. logical, intent(in), optional :: linearize Return a \"linearized\" string of tags without the XML hieararchy. Return Value character(len=:), allocatable Output string containing the whole tag. Subroutines private pure subroutine add_child_id (self, child_id) Add child ID to children IDs list. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. integer(kind=I4P), intent(in) :: child_id Child ID. private elemental subroutine free (self) Free (reset) tag. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. private pure subroutine get_content (self, name, content) Return tag content of self (or its nested tags) if named name . Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. character(len=*), intent(in) :: name Searched tag name. character(len=:), intent(out), allocatable :: content Tag content. private elemental subroutine parse (self, source, tstart, tend) Parse the tag contained into a source string. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the string. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the string. private elemental subroutine parse_tag_name (self, source, tstart, tend) Parse the tag name contained into a string. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the source. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the source. private pure subroutine set (self, name, attribute, attributes, attributes_stream, sanitize_attributes_value, content, pos, indent, is_content_indented, is_self_closing, id, level, parent_id, attributes_stream_alloc, content_alloc) Set tag data. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in), optional :: name Tag name. character(len=*), intent(in), optional :: attribute (1:) Attribute name/value pair [1:2]. character(len=*), intent(in), optional :: attributes (1:,1:) Attributes list of name/value pairs [1:2,1:]. character(len=*), intent(in), optional :: attributes_stream Attributes list of name/value pairs as stream. logical, intent(in), optional :: sanitize_attributes_value Sanitize attributes value. character(len=*), intent(in), optional :: content Tag value. integer(kind=I4P), intent(in), optional :: pos (1:) Characters position (in source) indexes. integer(kind=I4P), intent(in), optional :: indent Number of indent-white-spaces. logical, intent(in), optional :: is_content_indented Activate value indentation. logical, intent(in), optional :: is_self_closing The tag is self closing. integer(kind=I4P), intent(in), optional :: id Uniq ID. integer(kind=I4P), intent(in), optional :: level Tag hierarchy level. integer(kind=I4P), intent(in), optional :: parent_id Parent uniq ID. character(len=:), intent(in), optional, allocatable :: attributes_stream_alloc Attributes list stream, allocatable input. character(len=:), intent(in), optional, allocatable :: content_alloc Tag value, allocatable input. private  subroutine write_tag (self, unit, is_indented, is_content_indented, form, end_record, only_start, only_content, only_end, iostat, iomsg) Write tag to unit file. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. integer(kind=I4P), intent(in) :: unit File unit. logical, intent(in), optional :: is_indented Activate content indentation. logical, intent(in), optional :: is_content_indented Activate content indentation. character(len=*), intent(in), optional :: form Format. character(len=*), intent(in), optional :: end_record Ending record. logical, intent(in), optional :: only_start Write only start tag. logical, intent(in), optional :: only_content Write only content. logical, intent(in), optional :: only_end Write only end tag. integer(kind=I4P), intent(out), optional :: iostat IO status. character(len=*), intent(out), optional :: iomsg IO message. private pure subroutine add_single_attribute (self, attribute, sanitize_value) Add one attribute name/value pair. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attribute (1:) Attribute name/value pair [1:2]. logical, intent(in), optional :: sanitize_value Sanitize attribute value. private pure subroutine add_multiple_attributes (self, attributes, sanitize_values) Add list of attributes name/value pairs. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attributes (1:,1:) Attribute name/value pair list [1:2,1:]. logical, intent(in), optional :: sanitize_values Sanitize attribute values. private pure subroutine add_stream_attributes (self, attributes_stream, sanitize_values) Add list of attributes name/value pairs passed as stream. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: attributes_stream Attribute name/value pair list passed as stream. logical, intent(in), optional :: sanitize_values Sanitize attribute values. private elemental subroutine alloc_attributes (self, Na) Allocate (prepare for filling) dynamic memory of attributes. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. integer(kind=I4P), intent(in) :: Na Number of attributes. private pure subroutine delete_content (self) Delete tag content. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. private pure subroutine delete_single_attribute (self, name) Delete one attribute name/value pair. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: name Attribute name. private pure subroutine delete_multiple_attributes (self, name) Delete list of attributes name/value pairs. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: name (1:) Attributes names. private elemental subroutine get (self, source) Get the tag content and attributes from source after tag_name and attributes names have been set. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. private elemental subroutine get_attributes (self, source) Get the attributes values from source after tag_name and attributes names have been set. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. private elemental subroutine get_value (self, source) Get the tag value from source after tag_name has been set. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. private elemental subroutine parse_attributes_names (self, source) Parse the tag attributes names contained into a string. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. private elemental subroutine search (self, tag_name, source, tstart, tend) Search tag named tag_name into a string and, in case it is found, store into self. Read more… Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: tag_name Searched tag name. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the source. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the source. private elemental subroutine assign_tag (lhs, rhs) Assignment between two tags. Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: lhs Left hand side. type( xml_tag ), intent(in) :: rhs Right hand side. private elemental subroutine finalize (tag) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( xml_tag ), intent(inout) :: tag XML tag.","tags":"","url":"module/foxy_xml_tag.html"},{"title":"foxy_xml_file – FoXy","text":"FoXy XML file class. Uses foxy_xml_tag penf module~~foxy_xml_file~~UsesGraph module~foxy_xml_file foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy_xml_file->module~foxy_xml_tag penf penf module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~foxy_xml_file~~UsedByGraph module~foxy_xml_file foxy_xml_file module~foxy foxy module~foxy->module~foxy_xml_file program~foxy_test_add_attributes foxy_test_add_attributes program~foxy_test_add_attributes->module~foxy program~foxy_test_add_tag foxy_test_add_tag program~foxy_test_add_tag->module~foxy program~foxy_test_create_tag foxy_test_create_tag program~foxy_test_create_tag->module~foxy program~foxy_test_delete_attributes foxy_test_delete_attributes program~foxy_test_delete_attributes->module~foxy program~foxy_test_delete_content foxy_test_delete_content program~foxy_test_delete_content->module~foxy program~foxy_test_delete_tag foxy_test_delete_tag program~foxy_test_delete_tag->module~foxy program~foxy_test_indent_tag foxy_test_indent_tag program~foxy_test_indent_tag->module~foxy program~foxy_test_parse_file_simple foxy_test_parse_file_simple program~foxy_test_parse_file_simple->module~foxy program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags program~foxy_test_parse_string_nested_tags->module~foxy program~foxy_test_parse_string_simple foxy_test_parse_string_simple program~foxy_test_parse_string_simple->module~foxy program~foxy_test_write_tag foxy_test_write_tag program~foxy_test_write_tag->module~foxy Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: xml_file XML file class. Components Type Visibility Attributes Name Initial type( xml_tag ), private, allocatable :: tag (:) XML tags array. integer(kind=I4P), private :: nt = 0_I4P Number of XML tags. Finalizations Procedures final :: finalize Free dynamic memory when finalizing. Type-Bound Procedures procedure, public, pass(self) :: add_tag Add tag to XML file. procedure, public, pass(self) :: content Return tag content of tag named name . procedure, public, pass(self) :: delete_tag Add tag from XML file. procedure, public, pass(self) :: free Free dynamic memory. procedure, public, pass(self) :: parse Parse xml file. procedure, public, pass(self) :: stringify Convert the whole file data into a string. procedure, private, pass(self) :: add_child Add child ID to tag children list. procedure, private, pass(self) :: parse_from_string Parse xml data from string. procedure, private, pass(self) :: stringify_recursive Convert recursively tags with children into a string. Functions private pure function content (self, name) Return tag content of tag named name . Read more… Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. character(len=*), intent(in) :: name Tag name. Return Value character(len=:), allocatable Tag content. private pure function stringify (self, linearize) result(string) Convert the whole file data into a string. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. logical, intent(in), optional :: linearize Return a \"linearized\" string of tags without the XML hieararchy. Return Value character(len=:), allocatable Output string containing the whole xml file. private  function load_file_as_stream (filename, delimiter_start, delimiter_end, fast_read, iostat, iomsg) result(stream) Load file contents and store as single characters stream. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File name. character(len=*), intent(in), optional :: delimiter_start Delimiter from which start the stream. character(len=*), intent(in), optional :: delimiter_end Delimiter to which end the stream. logical, intent(in), optional :: fast_read Flag for activating efficient reading with one single read. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Return Value character(len=:), allocatable Output string containing the file data as a single stream. Subroutines private elemental subroutine add_tag (self, tag) Add tag to XML file. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. type( xml_tag ), intent(in) :: tag XML tag. private elemental subroutine delete_tag (self, name) Delete tag from XML file. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. character(len=*), intent(in) :: name XML tag name. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. private  subroutine parse (self, string, filename) Parse xml data from string or file.\nXML data is linearized, a DOM structured is used. Read more… Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. character(len=*), intent(in), optional :: string String containing xml data. character(len=*), intent(in), optional :: filename File name containing xml data. private pure subroutine add_child (self, parent_id, child_id) Add child ID to tag children list. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file handler. integer(kind=I4P), intent(in) :: parent_id Parent ID. integer(kind=I4P), intent(in) :: child_id Child ID. private pure subroutine parse_from_string (self, source_string) Parse xml data from a chunk of source string (file stringified for IO on device). Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file handler. character(len=*), intent(in) :: source_string String containing xml data. private pure recursive subroutine stringify_recursive (self, tag, is_done, tag_string) Convert recursively tags with children into a string. Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. type( xml_tag ), intent(in) :: tag XML tag with children. logical, intent(inout) :: is_done (:) List of stringified tags. character(len=:), intent(inout), allocatable :: tag_string Output string containing the current tag. private  subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( xml_file ), intent(inout) :: self XML file. private pure subroutine find_matching_end_tag (source, start_pos, tag_name, end_pos) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source Source containing tag content. integer(kind=I4P), intent(in) :: start_pos Start tag content position. character(len=*), intent(in) :: tag_name Tag name. integer(kind=I4P), intent(out) :: end_pos End tag position. private pure subroutine get_tag_content (source, tag_name, start_pos, content, end_pos) Get tag content. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source Source containing tag content. character(len=*), intent(in) :: tag_name Tag name. integer, intent(in) :: start_pos Start tag content position. character(len=:), intent(out), allocatable :: content Extracted tag content. integer(kind=I4P), intent(out), optional :: end_pos End tag content position. private pure subroutine parse_tag_name (tag_str, tag_name, attributes_str, is_closing, is_self_closing) Parse current tag, only name and attributes. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tag_str Tag string. character(len=:), intent(out), allocatable :: tag_name Parsed tag name. character(len=:), intent(out), allocatable :: attributes_str Parsed attributes list. logical, intent(out) :: is_closing Sentinel for closing tag. logical, intent(out) :: is_self_closing Sentinel for self closing tag.","tags":"","url":"module/foxy_xml_file.html"},{"title":"foxy_test_delete_tag – FoXy","text":"Uses foxy program~~foxy_test_delete_tag~~UsesGraph program~foxy_test_delete_tag foxy_test_delete_tag module~foxy foxy program~foxy_test_delete_tag->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_delete_tag~~CallsGraph program~foxy_test_delete_tag foxy_test_delete_tag proc~delete_tag xml_file%delete_tag program~foxy_test_delete_tag->proc~delete_tag proc~parse~2 xml_file%parse program~foxy_test_delete_tag->proc~parse~2 proc~stringify~2 xml_file%stringify program~foxy_test_delete_tag->proc~stringify~2 proc~name xml_tag%name proc~delete_tag->proc~name proc~load_file_as_stream load_file_as_stream proc~parse~2->proc~load_file_as_stream proc~parse_from_string xml_file%parse_from_string proc~parse~2->proc~parse_from_string proc~stringify xml_tag%stringify proc~stringify~2->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify~2->proc~stringify_recursive chars chars proc~name->chars proc~add_child xml_file%add_child proc~parse_from_string->proc~add_child proc~add_tag xml_file%add_tag proc~parse_from_string->proc~add_tag proc~get_tag_content get_tag_content proc~parse_from_string->proc~get_tag_content proc~parse_tag_name~2 parse_tag_name proc~parse_from_string->proc~parse_tag_name~2 proc~set xml_tag%set proc~parse_from_string->proc~set proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive proc~add_child_id xml_tag%add_child_id proc~add_child->proc~add_child_id proc~find_matching_end_tag find_matching_end_tag proc~get_tag_content->proc~find_matching_end_tag proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_file ) :: a_file XML tag handler. type( xml_tag ) :: a_tag XML tag handler. type( xml_tag ) :: another_tag XML tag handler. logical :: test_passed (2) List of passed tests. Source Code program foxy_test_delete_tag !< FoXy test. use foxy , only : xml_file , xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: a_file !< XML tag handler. type ( xml_tag ) :: a_tag !< XML tag handler. type ( xml_tag ) :: another_tag !< XML tag handler. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' print \"(A)\" , source print \"(A)\" , 'parsed' call a_file % parse ( string = source ) print \"(A)\" , 'remove \"third\" tag' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' call a_file % delete_tag ( name = \"third\" ) parsed = a_file % stringify () test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'remove \"first\" tag' source = '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' call a_file % delete_tag ( name = \"first\" ) parsed = a_file % stringify () test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_delete_tag","tags":"","url":"program/foxy_test_delete_tag.html"},{"title":"foxy_test_parse_file_simple – FoXy","text":"Uses foxy program~~foxy_test_parse_file_simple~~UsesGraph program~foxy_test_parse_file_simple foxy_test_parse_file_simple module~foxy foxy program~foxy_test_parse_file_simple->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_parse_file_simple~~CallsGraph program~foxy_test_parse_file_simple foxy_test_parse_file_simple proc~parse~2 xml_file%parse program~foxy_test_parse_file_simple->proc~parse~2 proc~stringify~2 xml_file%stringify program~foxy_test_parse_file_simple->proc~stringify~2 proc~load_file_as_stream load_file_as_stream proc~parse~2->proc~load_file_as_stream proc~parse_from_string xml_file%parse_from_string proc~parse~2->proc~parse_from_string proc~stringify xml_tag%stringify proc~stringify~2->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify~2->proc~stringify_recursive proc~add_child xml_file%add_child proc~parse_from_string->proc~add_child proc~add_tag xml_file%add_tag proc~parse_from_string->proc~add_tag proc~get_tag_content get_tag_content proc~parse_from_string->proc~get_tag_content proc~parse_tag_name~2 parse_tag_name proc~parse_from_string->proc~parse_tag_name~2 proc~set xml_tag%set proc~parse_from_string->proc~set chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive proc~add_child_id xml_tag%add_child_id proc~add_child->proc~add_child_id proc~find_matching_end_tag find_matching_end_tag proc~get_tag_content->proc~find_matching_end_tag proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_file ) :: xfile XML file handler. integer :: xunit XML file unit. logical :: test_passed (1) List of passed tests. Source Code program foxy_test_parse_file_simple !< FoXy test. use foxy , only : xml_file implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. integer :: xunit !< XML file unit. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested level=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '  <nested2 level=\"1\">' // new_line ( 'a' ) // & '    <nested3 level=\"2\">Nested tag at level 2</nested3>' // new_line ( 'a' ) // & '  </nested2>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' ) write ( unit = xunit ) source close ( unit = xunit ) print \"(A)\" , 'Parsing file' call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) open ( newunit = xunit , file = 'parse_file_simple.xml' ) close ( unit = xunit , status = 'DELETE' ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_parse_file_simple","tags":"","url":"program/foxy_test_parse_file_simple.html"},{"title":"foxy_test_add_tag – FoXy","text":"Uses foxy program~~foxy_test_add_tag~~UsesGraph program~foxy_test_add_tag foxy_test_add_tag module~foxy foxy program~foxy_test_add_tag->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_add_tag~~CallsGraph program~foxy_test_add_tag foxy_test_add_tag proc~add_tag xml_file%add_tag program~foxy_test_add_tag->proc~add_tag proc~stringify~2 xml_file%stringify program~foxy_test_add_tag->proc~stringify~2 proc~stringify xml_tag%stringify proc~stringify~2->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify~2->proc~stringify_recursive chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_file ) :: a_file XML tag handler. type( xml_tag ) :: a_tag XML tag handler. type( xml_tag ) :: another_tag XML tag handler. logical :: test_passed (1) List of passed tests. Source Code program foxy_test_add_tag !< FoXy test. use foxy , only : xml_file , xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: a_file !< XML tag handler. type ( xml_tag ) :: a_tag !< XML tag handler. type ( xml_tag ) :: another_tag !< XML tag handler. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested l=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_file % add_tag ( tag = a_tag ) a_tag = xml_tag ( name = 'second' , attribute = [ 'a1' , '2 ' ], is_self_closing = . true ., sanitize_attributes_value = . true .) call a_file % add_tag ( tag = a_tag ) a_tag = xml_tag ( name = 'third' , content = 'bye' ) call a_file % add_tag ( tag = a_tag ) a_tag = xml_tag ( name = 'fourth' , content = 'bye bye Mrs. Robinson' , attribute = [ 'a' , '3' ]) call a_file % add_tag ( tag = a_tag ) another_tag = xml_tag ( name = 'nested' , content = 'I am supported! Nested tag at level 1' , attribute = [ 'l' , '1' ]) a_tag = xml_tag ( name = 'fift' , content = another_tag , is_content_indented = . true .) call a_file % add_tag ( tag = a_tag ) parsed = a_file % stringify () test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_add_tag","tags":"","url":"program/foxy_test_add_tag.html"},{"title":"foxy_test_add_attributes – FoXy","text":"Uses foxy program~~foxy_test_add_attributes~~UsesGraph program~foxy_test_add_attributes foxy_test_add_attributes module~foxy foxy program~foxy_test_add_attributes->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_add_attributes~~CallsGraph program~foxy_test_add_attributes foxy_test_add_attributes none~add_attributes xml_tag%add_attributes program~foxy_test_add_attributes->none~add_attributes proc~stringify xml_tag%stringify program~foxy_test_add_attributes->proc~stringify proc~add_multiple_attributes xml_tag%add_multiple_attributes none~add_attributes->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute none~add_attributes->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes none~add_attributes->proc~add_stream_attributes chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_tag ) :: a_tag XML tag handler. logical :: test_passed (3) List of passed tests. Source Code program foxy_test_add_attributes !< FoXy test. use foxy , only : xml_file , xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 3 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) parsed = a_tag % stringify () test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) call a_tag % add_attributes ( attributes_stream = 'y=\"3\" a=\"one\" b = \"two\" cc=\"tree\"' ) print \"(A)\" , 'source' source = '<first x=\"1\" y=\"3\" z=\"2\" a=\"one\" b=\"two\" cc=\"tree\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' parsed = a_tag % stringify () test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) call a_tag % add_attributes ( attributes_stream = '' ) print \"(A)\" , 'source' source = '<first x=\"1\" y=\"3\" z=\"2\" a=\"one\" b=\"two\" cc=\"tree\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' parsed = a_tag % stringify () test_passed ( 3 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 3 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_add_attributes","tags":"","url":"program/foxy_test_add_attributes.html"},{"title":"foxy_test_delete_attributes – FoXy","text":"Uses foxy program~~foxy_test_delete_attributes~~UsesGraph program~foxy_test_delete_attributes foxy_test_delete_attributes module~foxy foxy program~foxy_test_delete_attributes->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_delete_attributes~~CallsGraph program~foxy_test_delete_attributes foxy_test_delete_attributes none~delete_attributes xml_tag%delete_attributes program~foxy_test_delete_attributes->none~delete_attributes proc~stringify xml_tag%stringify program~foxy_test_delete_attributes->proc~stringify proc~delete_multiple_attributes xml_tag%delete_multiple_attributes none~delete_attributes->proc~delete_multiple_attributes proc~delete_single_attribute xml_tag%delete_single_attribute none~delete_attributes->proc~delete_single_attribute chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~delete_multiple_attributes->proc~delete_single_attribute Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_tag ) :: a_tag XML tag handler. logical :: test_passed (4) List of passed tests. Source Code program foxy_test_delete_attributes !< FoXy test. use foxy , only : xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 4 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'delete \"y\" attribute' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = \"y\" ) parsed = a_tag % stringify () source = '<first x=\"1\" z=\"2\">lorem ipsum...</first>' test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'delete \"x\" attribute' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = \"x\" ) parsed = a_tag % stringify () source = '<first y=\"c\" z=\"2\">lorem ipsum...</first>' test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) print \"(A)\" , 'delete \"z\" attribute' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = \"z\" ) parsed = a_tag % stringify () source = '<first x=\"1\" y=\"c\">lorem ipsum...</first>' test_passed ( 3 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 3 ) print \"(A)\" , 'delete \"x\" \"z\" attributes' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = [ \"z\" , \"x\" ]) parsed = a_tag % stringify () source = '<first y=\"c\">lorem ipsum...</first>' test_passed ( 4 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 4 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_delete_attributes","tags":"","url":"program/foxy_test_delete_attributes.html"},{"title":"foxy_test_write_tag – FoXy","text":"Uses foxy program~~foxy_test_write_tag~~UsesGraph program~foxy_test_write_tag foxy_test_write_tag module~foxy foxy program~foxy_test_write_tag->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_write_tag~~CallsGraph program~foxy_test_write_tag foxy_test_write_tag proc~parse~2 xml_file%parse program~foxy_test_write_tag->proc~parse~2 proc~stringify~2 xml_file%stringify program~foxy_test_write_tag->proc~stringify~2 proc~load_file_as_stream load_file_as_stream proc~parse~2->proc~load_file_as_stream proc~parse_from_string xml_file%parse_from_string proc~parse~2->proc~parse_from_string proc~stringify xml_tag%stringify proc~stringify~2->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify~2->proc~stringify_recursive proc~add_child xml_file%add_child proc~parse_from_string->proc~add_child proc~add_tag xml_file%add_tag proc~parse_from_string->proc~add_tag proc~get_tag_content get_tag_content proc~parse_from_string->proc~get_tag_content proc~parse_tag_name~2 parse_tag_name proc~parse_from_string->proc~parse_tag_name~2 proc~set xml_tag%set proc~parse_from_string->proc~set chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive proc~add_child_id xml_tag%add_child_id proc~add_child->proc~add_child_id proc~find_matching_end_tag find_matching_end_tag proc~get_tag_content->proc~find_matching_end_tag proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_tag ) :: a_tag XML tag handler. type( xml_file ) :: xfile XML file handler. integer :: xunit XML file unit. logical :: test_passed (3) List of passed tests. Source Code program foxy_test_write_tag !< FoXy test. use foxy implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. type ( xml_file ) :: xfile !< XML file handler. integer :: xunit !< XML file unit. logical :: test_passed ( 3 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' , status = 'REPLACE' ) print \"(A)\" , 'write tag' call a_tag % write ( unit = xunit , form = 'unformatted' ) close ( unit = xunit ) call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">' // new_line ( 'a' ) // '  lorem ipsum...' // new_line ( 'a' ) // '</first>' print \"(A)\" , source a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' , status = 'REPLACE' ) print \"(A)\" , 'write tag' call a_tag % write ( unit = xunit , form = 'unformatted' , is_indented = . true ., is_content_indented = . true .) close ( unit = xunit ) call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 2 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 2 ) open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' , status = 'REPLACE' ) print \"(A)\" , 'write tag' call a_tag % write ( unit = xunit , form = 'unformatted' , is_indented = . true ., only_start = . true ., end_record = new_line ( 'a' )) call a_tag % write ( unit = xunit , form = 'unformatted' , is_content_indented = . true ., only_content = . true ., end_record = new_line ( 'a' )) call a_tag % write ( unit = xunit , form = 'unformatted' , is_indented = . true ., only_end = . true .) close ( unit = xunit ) call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 3 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 3 ) open ( newunit = xunit , file = 'parse_file_simple.xml' ) close ( unit = xunit , status = 'DELETE' ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_write_tag","tags":"","url":"program/foxy_test_write_tag.html"},{"title":"foxy_test_parse_string_simple – FoXy","text":"Uses foxy program~~foxy_test_parse_string_simple~~UsesGraph program~foxy_test_parse_string_simple foxy_test_parse_string_simple module~foxy foxy program~foxy_test_parse_string_simple->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_parse_string_simple~~CallsGraph program~foxy_test_parse_string_simple foxy_test_parse_string_simple proc~parse~2 xml_file%parse program~foxy_test_parse_string_simple->proc~parse~2 proc~stringify~2 xml_file%stringify program~foxy_test_parse_string_simple->proc~stringify~2 proc~load_file_as_stream load_file_as_stream proc~parse~2->proc~load_file_as_stream proc~parse_from_string xml_file%parse_from_string proc~parse~2->proc~parse_from_string proc~stringify xml_tag%stringify proc~stringify~2->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify~2->proc~stringify_recursive proc~add_child xml_file%add_child proc~parse_from_string->proc~add_child proc~add_tag xml_file%add_tag proc~parse_from_string->proc~add_tag proc~get_tag_content get_tag_content proc~parse_from_string->proc~get_tag_content proc~parse_tag_name~2 parse_tag_name proc~parse_from_string->proc~parse_tag_name~2 proc~set xml_tag%set proc~parse_from_string->proc~set chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive proc~add_child_id xml_tag%add_child_id proc~add_child->proc~add_child_id proc~find_matching_end_tag find_matching_end_tag proc~get_tag_content->proc~find_matching_end_tag proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_file ) :: xfile XML file handler. logical :: test_passed (1) List of passed tests. Source Code program foxy_test_parse_string_simple !< FoXy test. use foxy , only : xml_file implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested level=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '  <nested2 level=\"1\">' // new_line ( 'a' ) // & '    <nested3 level=\"2\">Nested tag at level 2</nested3>' // new_line ( 'a' ) // & '  </nested2>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source print \"(A)\" , 'Parsing file' call xfile % parse ( string = source ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_parse_string_simple","tags":"","url":"program/foxy_test_parse_string_simple.html"},{"title":"foxy_test_delete_content – FoXy","text":"Uses foxy program~~foxy_test_delete_content~~UsesGraph program~foxy_test_delete_content foxy_test_delete_content module~foxy foxy program~foxy_test_delete_content->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_delete_content~~CallsGraph program~foxy_test_delete_content foxy_test_delete_content proc~delete_content xml_tag%delete_content program~foxy_test_delete_content->proc~delete_content proc~stringify xml_tag%stringify program~foxy_test_delete_content->proc~stringify chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_tag ) :: a_tag XML tag handler. logical :: test_passed (1) List of passed tests. Source Code program foxy_test_delete_content !< FoXy test. use foxy , only : xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'delete content' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_content () parsed = a_tag % stringify () source = '<first x=\"1\" y=\"c\" z=\"2\"></first>' test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_delete_content","tags":"","url":"program/foxy_test_delete_content.html"},{"title":"foxy_test_parse_string_nested_tags – FoXy","text":"Uses foxy program~~foxy_test_parse_string_nested_tags~~UsesGraph program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags module~foxy foxy program~foxy_test_parse_string_nested_tags->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_parse_string_nested_tags~~CallsGraph program~foxy_test_parse_string_nested_tags foxy_test_parse_string_nested_tags proc~parse~2 xml_file%parse program~foxy_test_parse_string_nested_tags->proc~parse~2 proc~stringify~2 xml_file%stringify program~foxy_test_parse_string_nested_tags->proc~stringify~2 proc~load_file_as_stream load_file_as_stream proc~parse~2->proc~load_file_as_stream proc~parse_from_string xml_file%parse_from_string proc~parse~2->proc~parse_from_string proc~stringify xml_tag%stringify proc~stringify~2->proc~stringify proc~stringify_recursive xml_file%stringify_recursive proc~stringify~2->proc~stringify_recursive proc~add_child xml_file%add_child proc~parse_from_string->proc~add_child proc~add_tag xml_file%add_tag proc~parse_from_string->proc~add_tag proc~get_tag_content get_tag_content proc~parse_from_string->proc~get_tag_content proc~parse_tag_name~2 parse_tag_name proc~parse_from_string->proc~parse_tag_name~2 proc~set xml_tag%set proc~parse_from_string->proc~set chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~stringify_recursive->proc~stringify proc~stringify_recursive->proc~stringify_recursive proc~add_child_id xml_tag%add_child_id proc~add_child->proc~add_child_id proc~find_matching_end_tag find_matching_end_tag proc~get_tag_content->proc~find_matching_end_tag proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_file ) :: xfile XML file handler. logical :: test_passed (1) List of passed tests. integer :: f Source Code program foxy_test_parse_string_nested_tags !< FoXy test. use foxy , only : xml_file implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. logical :: test_passed ( 1 ) !< List of passed tests. integer f test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<tag1 level=\"1\">lorem ipsum...</tag1>' // new_line ( 'a' ) // & '<tag2 level=\"1\" type=\"self_closing\"/>' // new_line ( 'a' ) // & '<tag3 level=\"1\">bye</tag3>' // new_line ( 'a' ) // & '<tag4 level=\"1\">bye bye Mrs. Robinson</tag4>' // new_line ( 'a' ) // & '<tag4 level=\"1\" type=\"repeat\">here we are, again</tag4>' // new_line ( 'a' ) // & '<tag4 level=\"1\" type=\"repeat_bis\">and again</tag4>' // new_line ( 'a' ) // & '<tag4 level=\"1\" type=\"repeat_tris\">forever</tag4>' // new_line ( 'a' ) // & '<tag5>' // new_line ( 'a' ) // & '  <tag6 level=\"2\">content of tag6</tag6>' // new_line ( 'a' ) // & '  <tag7 level=\"2\">' // new_line ( 'a' ) // & '    <tag7 level=\"3\" type=\"nested\">content of tag7 nested</tag7>' // new_line ( 'a' ) // & '    <tag8 level=\"3\">content of tag8</tag8>' // new_line ( 'a' ) // & '    <tag7 level=\"3\" type=\"nested repeat\">content of tag7 nested repeat</tag7>' // new_line ( 'a' ) // & '    <tag9 level=\"3\">' // new_line ( 'a' ) // & '      <tag10 level=\"4\">content of tag10</tag10>' // new_line ( 'a' ) // & '    </tag9>' // new_line ( 'a' ) // & '    <tag7 level=\"3\" type=\"nested\">' // new_line ( 'a' ) // & '      <tag7 level=\"4\" type=\"nested double\">content of tag7 nested double</tag7>' // new_line ( 'a' ) // & '    </tag7>' // new_line ( 'a' ) // & '  </tag7>' // new_line ( 'a' ) // & '</tag5>' // new_line ( 'a' ) // & '<tag11 level=\"1\" type=\"self_closing\"/>' print \"(A)\" , source print \"(A)\" , 'Parsing file' call xfile % parse ( string = source ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) print \"(A)\" , 'Parsed data linearized' print \"(A)\" , xfile % stringify ( linearize = . true .) open ( newunit = f , file = 'source.xml' ) write ( f , '(A)' ) source close ( f ) open ( newunit = f , file = 'parsed.xml' ) write ( f , '(A)' ) parsed close ( f ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_parse_string_nested_tags","tags":"","url":"program/foxy_test_parse_string_nested_tags.html"},{"title":"foxy_test_indent_tag – FoXy","text":"Uses foxy program~~foxy_test_indent_tag~~UsesGraph program~foxy_test_indent_tag foxy_test_indent_tag module~foxy foxy program~foxy_test_indent_tag->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_indent_tag~~CallsGraph program~foxy_test_indent_tag foxy_test_indent_tag proc~stringify xml_tag%stringify program~foxy_test_indent_tag->proc~stringify chars chars proc~stringify->chars is_allocated is_allocated proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_tag ) :: a_tag XML tag handler. logical :: test_passed (2) List of passed tests. Source Code program foxy_test_indent_tag !< FoXy test. use foxy , only : xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '  <first>lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , indent = 2 ) parsed = a_tag % stringify ( is_indented = . true .) test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'source' source = '  <first>' // new_line ( 'a' ) // & '    lorem ipsum...' // new_line ( 'a' ) // & '  </first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , indent = 2 ) parsed = a_tag % stringify ( is_indented = . true ., is_content_indented = . true .) test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_indent_tag","tags":"","url":"program/foxy_test_indent_tag.html"},{"title":"foxy_test_create_tag – FoXy","text":"Uses foxy program~~foxy_test_create_tag~~UsesGraph program~foxy_test_create_tag foxy_test_create_tag module~foxy foxy program~foxy_test_create_tag->module~foxy module~foxy_xml_file foxy_xml_file module~foxy->module~foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy->module~foxy_xml_tag penf penf module~foxy->penf module~foxy_xml_file->module~foxy_xml_tag module~foxy_xml_file->penf module~foxy_xml_tag->penf stringifor stringifor module~foxy_xml_tag->stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. FoXy test. Calls program~~foxy_test_create_tag~~CallsGraph program~foxy_test_create_tag foxy_test_create_tag proc~parse xml_tag%parse program~foxy_test_create_tag->proc~parse proc~set xml_tag%set program~foxy_test_create_tag->proc~set proc~stringify xml_tag%stringify program~foxy_test_create_tag->proc~stringify is_allocated is_allocated proc~parse->is_allocated proc~get xml_tag%get proc~parse->proc~get proc~parse_attributes_names xml_tag%parse_attributes_names proc~parse->proc~parse_attributes_names proc~parse_tag_name xml_tag%parse_tag_name proc~parse->proc~parse_tag_name proc~add_multiple_attributes xml_tag%add_multiple_attributes proc~set->proc~add_multiple_attributes proc~add_single_attribute xml_tag%add_single_attribute proc~set->proc~add_single_attribute proc~add_stream_attributes xml_tag%add_stream_attributes proc~set->proc~add_stream_attributes chars chars proc~stringify->chars proc~stringify->is_allocated proc~end_tag xml_tag%end_tag proc~stringify->proc~end_tag proc~self_closing_tag xml_tag%self_closing_tag proc~stringify->proc~self_closing_tag proc~start_tag xml_tag%start_tag proc~stringify->proc~start_tag proc~add_multiple_attributes->proc~add_single_attribute proc~alloc_attributes xml_tag%alloc_attributes proc~add_single_attribute->proc~alloc_attributes proc~add_stream_attributes->proc~add_single_attribute fill fill proc~add_stream_attributes->fill partition partition proc~add_stream_attributes->partition slice slice proc~add_stream_attributes->slice proc~get_attributes xml_tag%get_attributes proc~get->proc~get_attributes proc~get_value xml_tag%get_value proc~get->proc~get_value proc~parse_attributes_names->proc~alloc_attributes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_tag ) :: a_tag XML tag handler. logical :: test_passed (4) List of passed tests. Source Code program foxy_test_create_tag !< FoXy test. use foxy , only : xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 4 ) !< List of passed tests. test_passed = . false . ! create using xml_tag overloaded procedures print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) parsed = a_tag % stringify () test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // 'Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'source' source = '<second x=\"1\" y=\"c\" z=\"2\"/>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'second' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ]), is_self_closing = . true .) parsed = a_tag % stringify () test_passed ( 2 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) ! create parsing a source print \"(A)\" , 'source' source = '<third x=\"1\" y=\"c\" z=\"2\"/>' print \"(A)\" , source print \"(A)\" , 'created' call a_tag % set ( name = 'third' ) call a_tag % parse ( source = source ) parsed = a_tag % stringify () test_passed ( 3 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 3 ) print \"(A)\" , 'source' source = '<fourth x=\"1\" y=\"c\" z=\"2\"></fourth>' print \"(A)\" , source print \"(A)\" , 'created' call a_tag % set ( name = 'fourth' ) call a_tag % parse ( source = source ) parsed = a_tag % stringify () test_passed ( 4 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 4 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_create_tag","tags":"","url":"program/foxy_test_create_tag.html"},{"title":"foxy_test_delete_tag.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_delete_tag.f90~~EfferentGraph sourcefile~foxy_test_delete_tag.f90 foxy_test_delete_tag.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_delete_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_delete_tag !< FoXy test. use foxy , only : xml_file , xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: a_file !< XML tag handler. type ( xml_tag ) :: a_tag !< XML tag handler. type ( xml_tag ) :: another_tag !< XML tag handler. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' print \"(A)\" , source print \"(A)\" , 'parsed' call a_file % parse ( string = source ) print \"(A)\" , 'remove \"third\" tag' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' call a_file % delete_tag ( name = \"third\" ) parsed = a_file % stringify () test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'remove \"first\" tag' source = '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' call a_file % delete_tag ( name = \"first\" ) parsed = a_file % stringify () test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_delete_tag","tags":"","url":"sourcefile/foxy_test_delete_tag.f90.html"},{"title":"foxy_test_parse_file_simple.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_parse_file_simple.f90~~EfferentGraph sourcefile~foxy_test_parse_file_simple.f90 foxy_test_parse_file_simple.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_parse_file_simple.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_parse_file_simple !< FoXy test. use foxy , only : xml_file implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. integer :: xunit !< XML file unit. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested level=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '  <nested2 level=\"1\">' // new_line ( 'a' ) // & '    <nested3 level=\"2\">Nested tag at level 2</nested3>' // new_line ( 'a' ) // & '  </nested2>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' ) write ( unit = xunit ) source close ( unit = xunit ) print \"(A)\" , 'Parsing file' call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) open ( newunit = xunit , file = 'parse_file_simple.xml' ) close ( unit = xunit , status = 'DELETE' ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_parse_file_simple","tags":"","url":"sourcefile/foxy_test_parse_file_simple.f90.html"},{"title":"foxy.f90 – FoXy","text":"FoXy, Fortran XML parser for poor people This file depends on sourcefile~~foxy.f90~~EfferentGraph sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~foxy.f90~~AfferentGraph sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_add_attributes.f90 foxy_test_add_attributes.f90 sourcefile~foxy_test_add_attributes.f90->sourcefile~foxy.f90 sourcefile~foxy_test_add_tag.f90 foxy_test_add_tag.f90 sourcefile~foxy_test_add_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_create_tag.f90 foxy_test_create_tag.f90 sourcefile~foxy_test_create_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_delete_attributes.f90 foxy_test_delete_attributes.f90 sourcefile~foxy_test_delete_attributes.f90->sourcefile~foxy.f90 sourcefile~foxy_test_delete_content.f90 foxy_test_delete_content.f90 sourcefile~foxy_test_delete_content.f90->sourcefile~foxy.f90 sourcefile~foxy_test_delete_tag.f90 foxy_test_delete_tag.f90 sourcefile~foxy_test_delete_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_indent_tag.f90 foxy_test_indent_tag.f90 sourcefile~foxy_test_indent_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_parse_file_simple.f90 foxy_test_parse_file_simple.f90 sourcefile~foxy_test_parse_file_simple.f90->sourcefile~foxy.f90 sourcefile~foxy_test_parse_string_nested_tags.f90 foxy_test_parse_string_nested_tags.f90 sourcefile~foxy_test_parse_string_nested_tags.f90->sourcefile~foxy.f90 sourcefile~foxy_test_parse_string_simple.f90 foxy_test_parse_string_simple.f90 sourcefile~foxy_test_parse_string_simple.f90->sourcefile~foxy.f90 sourcefile~foxy_test_write_tag.f90 foxy_test_write_tag.f90 sourcefile~foxy_test_write_tag.f90->sourcefile~foxy.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy, Fortran XML parser for poor people module foxy !< FoXy, Fortran XML parser for poor people use foxy_xml_file , only : xml_file use foxy_xml_tag , only : xml_tag use penf implicit none private public :: I1P , I2P , I4P , I8P , R4P , R8P public :: xml_file public :: xml_tag endmodule foxy","tags":"","url":"sourcefile/foxy.f90.html"},{"title":"foxy_test_add_tag.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_add_tag.f90~~EfferentGraph sourcefile~foxy_test_add_tag.f90 foxy_test_add_tag.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_add_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_add_tag !< FoXy test. use foxy , only : xml_file , xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: a_file !< XML tag handler. type ( xml_tag ) :: a_tag !< XML tag handler. type ( xml_tag ) :: another_tag !< XML tag handler. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested l=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_file % add_tag ( tag = a_tag ) a_tag = xml_tag ( name = 'second' , attribute = [ 'a1' , '2 ' ], is_self_closing = . true ., sanitize_attributes_value = . true .) call a_file % add_tag ( tag = a_tag ) a_tag = xml_tag ( name = 'third' , content = 'bye' ) call a_file % add_tag ( tag = a_tag ) a_tag = xml_tag ( name = 'fourth' , content = 'bye bye Mrs. Robinson' , attribute = [ 'a' , '3' ]) call a_file % add_tag ( tag = a_tag ) another_tag = xml_tag ( name = 'nested' , content = 'I am supported! Nested tag at level 1' , attribute = [ 'l' , '1' ]) a_tag = xml_tag ( name = 'fift' , content = another_tag , is_content_indented = . true .) call a_file % add_tag ( tag = a_tag ) parsed = a_file % stringify () test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_add_tag","tags":"","url":"sourcefile/foxy_test_add_tag.f90.html"},{"title":"foxy_test_add_attributes.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_add_attributes.f90~~EfferentGraph sourcefile~foxy_test_add_attributes.f90 foxy_test_add_attributes.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_add_attributes.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_add_attributes !< FoXy test. use foxy , only : xml_file , xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 3 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) parsed = a_tag % stringify () test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) call a_tag % add_attributes ( attributes_stream = 'y=\"3\" a=\"one\" b = \"two\" cc=\"tree\"' ) print \"(A)\" , 'source' source = '<first x=\"1\" y=\"3\" z=\"2\" a=\"one\" b=\"two\" cc=\"tree\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' parsed = a_tag % stringify () test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) call a_tag % add_attributes ( attributes_stream = '' ) print \"(A)\" , 'source' source = '<first x=\"1\" y=\"3\" z=\"2\" a=\"one\" b=\"two\" cc=\"tree\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' parsed = a_tag % stringify () test_passed ( 3 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 3 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_add_attributes","tags":"","url":"sourcefile/foxy_test_add_attributes.f90.html"},{"title":"foxy_xml_tag.F90 – FoXy","text":"FoXy XML tag class. Files dependent on this one sourcefile~~foxy_xml_tag.f90~~AfferentGraph sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_test_add_attributes.f90 foxy_test_add_attributes.f90 sourcefile~foxy_test_add_attributes.f90->sourcefile~foxy.f90 sourcefile~foxy_test_add_tag.f90 foxy_test_add_tag.f90 sourcefile~foxy_test_add_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_create_tag.f90 foxy_test_create_tag.f90 sourcefile~foxy_test_create_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_delete_attributes.f90 foxy_test_delete_attributes.f90 sourcefile~foxy_test_delete_attributes.f90->sourcefile~foxy.f90 sourcefile~foxy_test_delete_content.f90 foxy_test_delete_content.f90 sourcefile~foxy_test_delete_content.f90->sourcefile~foxy.f90 sourcefile~foxy_test_delete_tag.f90 foxy_test_delete_tag.f90 sourcefile~foxy_test_delete_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_indent_tag.f90 foxy_test_indent_tag.f90 sourcefile~foxy_test_indent_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_parse_file_simple.f90 foxy_test_parse_file_simple.f90 sourcefile~foxy_test_parse_file_simple.f90->sourcefile~foxy.f90 sourcefile~foxy_test_parse_string_nested_tags.f90 foxy_test_parse_string_nested_tags.f90 sourcefile~foxy_test_parse_string_nested_tags.f90->sourcefile~foxy.f90 sourcefile~foxy_test_parse_string_simple.f90 foxy_test_parse_string_simple.f90 sourcefile~foxy_test_parse_string_simple.f90->sourcefile~foxy.f90 sourcefile~foxy_test_write_tag.f90 foxy_test_write_tag.f90 sourcefile~foxy_test_write_tag.f90->sourcefile~foxy.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy XML tag class. module foxy_xml_tag !< FoXy XML tag class. use penf use stringifor implicit none private public :: xml_tag type :: xml_tag !< XML tag class. !< !< A valid XML tag must have the following syntax for a tag without a content (with only attributes): !<```xml !<   <Tag_Name att#1_Name=\"att#1_val\" att#2_Name=\"att#2_val\"... att#Nt_Name=\"att#Nt_val\"/> !<``` !< while a tag with a content must have the following syntax: !<```xml !<   <Tag_Name att#1_Name=\"att#1_val\" att#2_Name=\"att#2_val\"... att#Nt_Name=\"att#Nt_val\">Tag_Content</Tag_Name> !<``` !< !< It is worth noting that the syntax is case sensitive and that the attributes are optional. Each attribute name must be !< followed by '=\"' without any additional white spaces and its value must be termined by '\"'. Each attribute is separated !< by one or more white spaces. private type ( string ) :: tag_name !< Tag name. type ( string ) :: tag_content !< Tag content. integer ( I4P ) :: pos ( 3 ) = [ 0_I4P , 0_I4P , 0_I4P ] !< Characters position (in source) indexes (start, content, end). type ( string ), allocatable :: attribute (:,:) !< Attributes names/values pairs, [1:2, 1:]. integer ( I4P ) :: attributes_number = 0_I4P !< Number of defined attributes. integer ( I4P ) :: indent = 0_I4P !< Number of indent-white-spaces. logical :: is_self_closing = . false . !< Self closing tag flag. integer ( I4P ) :: level = 0_I4P !< Tag hierarchy level. integer ( I4P ) :: id = 0_I4P !< Uniq tag ID. integer ( I4P ) :: parent_id = 0_I4P !< Uniq ID of parent tag. integer ( I4P ), public :: children_number = 0_I4P !< Number of children tags. integer ( I4P ), public , allocatable :: child_id (:) !< Uniq ID of children tags. contains ! public methods generic :: add_attributes => & add_single_attribute , & add_multiple_attributes , & add_stream_attributes !< Add attributes name/value pairs. procedure , pass ( self ) :: add_child_id !< Add child ID to children IDs list. procedure , pass ( self ) :: attributes !< Return attributes name/value pairs as string. generic :: delete_attributes => & delete_single_attribute , & delete_multiple_attributes !< Delete attributes name/value pairs. procedure , pass ( self ) :: delete_content !< Delete tag conent. procedure , pass ( self ) :: end_tag !< Return `</tag_name>` end tag. procedure , pass ( self ) :: free !< Free (reset) tag. procedure , pass ( self ) :: get_content !< Return tag content. procedure , pass ( self ) :: is_attribute_present !< Return .true. it the queried attribute name is defined. procedure , pass ( self ) :: is_parsed !< Check is tag is correctly parsed, i.e. its *tag_name* is allocated. procedure , pass ( self ) :: name !< Return tag name. procedure , pass ( self ) :: parse !< Parse the tag contained into a source string. procedure , pass ( self ) :: parse_tag_name !< Parse the tag name contained into a string. procedure , pass ( self ) :: self_closing_tag !< Return `<tag_name.../>` self closing tag. procedure , pass ( self ) :: set !< Set tag data. procedure , pass ( self ) :: start_tag !< Return `<tag_name...>` start tag. procedure , pass ( self ) :: stringify !< Convert the whole tag into a string. procedure , pass ( self ) :: write => write_tag !< Write tag to unit file. generic :: assignment ( = ) => assign_tag !< Assignment operator overloading. ! private methods procedure , pass ( self ), private :: add_single_attribute !< Add one attribute name/value pair. procedure , pass ( self ), private :: add_multiple_attributes !< Add list of attributes name/value pairs. procedure , pass ( self ), private :: add_stream_attributes !< Add list of attributes name/value pairs passed as stream. procedure , pass ( self ), private :: alloc_attributes !< Allocate (prepare for filling) dynamic memory of attributes. procedure , pass ( self ), private :: delete_single_attribute !< Delete one attribute name/value pair. procedure , pass ( self ), private :: delete_multiple_attributes !< Delete list of attributes name/value pairs. procedure , pass ( self ), private :: get !< Get the tag value and attributes from source. procedure , pass ( self ), private :: get_value !< Get the tag value from source after tag_name has been set. procedure , pass ( self ), private :: get_attributes !< Get the attributes values from source. procedure , pass ( self ), private :: parse_attributes_names !< Parse the tag attributes names contained into a string. procedure , pass ( self ), private :: search !< Search tag named *tag_name* into a string. ! operators procedure , pass ( lhs ), private :: assign_tag !< Assignment between two tags. final :: finalize !< Free dynamic memory when finalizing. endtype xml_tag interface xml_tag !< Overload *xml_tag* with creator procedures. module procedure create_tag_flat , create_tag_nested endinterface contains ! creator procedures overloading *xml_tag* name pure function create_tag_flat ( name , attribute , attributes , attributes_stream , sanitize_attributes_value , pos , content , & indent , is_content_indented , is_self_closing , id , level , parent_id , attributes_stream_alloc , & content_alloc ) result ( tag ) !< Return an instance of xml tag. character ( * ), intent ( in ) :: name !< Tag name. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list as single stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. integer ( I4P ), intent ( in ), optional :: pos ( 1 :) !< Characters position (in source) indexes. character ( * ), intent ( in ), optional :: content !< Tag value. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate content indentation. logical , intent ( in ), optional :: is_self_closing !< The tag is self closing. integer ( I4P ), intent ( in ), optional :: id !< Uniq ID. integer ( I4P ), intent ( in ), optional :: level !< Tag hierarchy level. integer ( I4P ), intent ( in ), optional :: parent_id !< Parent uniq ID. character (:), allocatable , intent ( in ), optional :: attributes_stream_alloc !< Attributes list stream, allocatable input. character (:), allocatable , intent ( in ), optional :: content_alloc !< Tag value, allocatable input. type ( xml_tag ) :: tag !< XML tag. call tag % set ( name = name , & attribute = attribute , & attributes = attributes , & attributes_stream = attributes_stream , & sanitize_attributes_value = sanitize_attributes_value , & content = content , & pos = pos , & indent = indent , & is_content_indented = is_content_indented , & is_self_closing = is_self_closing , & id = id , & level = level , & parent_id = parent_id , & attributes_stream_alloc = attributes_stream_alloc , & content_alloc = content_alloc ) endfunction create_tag_flat pure function create_tag_nested ( name , content , attribute , attributes , attributes_stream , sanitize_attributes_value , pos , indent ,& is_content_indented , id , level , parent_id , attributes_stream_alloc , content_alloc ) result ( tag ) !< Return an instance of xml tag with value being a nested tag. character ( * ), intent ( in ) :: name !< Tag name. type ( xml_tag ), intent ( in ) :: content !< Tag value as nested tag.. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list as single stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. integer ( I4P ), intent ( in ), optional :: pos ( 1 :) !< Characters position (in source) indexes. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate value indentation. integer ( I4P ), intent ( in ), optional :: id !< Uniq ID. integer ( I4P ), intent ( in ), optional :: level !< Tag hierarchy level. integer ( I4P ), intent ( in ), optional :: parent_id !< Parent uniq ID. character (:), allocatable , intent ( in ), optional :: attributes_stream_alloc !< Attributes list stream, allocatable input. character (:), allocatable , intent ( in ), optional :: content_alloc !< Tag value, allocatable input. type ( xml_tag ) :: tag !< XML tag. call tag % set ( name = name , & attribute = attribute , & attributes = attributes , & content = content % stringify (), & sanitize_attributes_value = sanitize_attributes_value , & attributes_stream = attributes_stream , & pos = pos , & indent = indent , & is_content_indented = is_content_indented , & id = id , & level = level , & parent_id = parent_id , & attributes_stream_alloc = attributes_stream_alloc , & content_alloc = content_alloc ) endfunction create_tag_nested ! public methods pure subroutine add_child_id ( self , child_id ) !< Add child ID to children IDs list. class ( xml_tag ), intent ( inout ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: child_id !< Child ID. if ( allocated ( self % child_id )) then self % child_id = [ self % child_id , child_id ] else self % child_id = [ child_id ] endif self % children_number = size ( self % child_id ) endsubroutine add_child_id pure function attributes ( self ) result ( att_ ) !< Return attributes name/value pairs as string. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( len = :), allocatable :: att_ !< The attributes string. integer ( I4P ) :: a !< Counter. if ( self % attributes_number > 0 ) then att_ = '' do a = 1 , self % attributes_number att_ = att_ // ' ' // self % attribute ( 1 , a ) // '=\"' // self % attribute ( 2 , a ) // '\"' enddo att_ = trim ( adjustl ( att_ )) endif endfunction attributes pure function end_tag ( self , is_indented ) result ( tag_ ) !< Return `</tag_name>` end tag. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Activate content indentation. character ( len = :), allocatable :: tag_ !< The end tag string. tag_ = '</' // self % tag_name // '>' if ( present ( is_indented )) then if ( is_indented ) tag_ = repeat ( ' ' , self % indent ) // tag_ endif endfunction end_tag elemental subroutine free ( self ) !< Free (reset) tag. class ( xml_tag ), intent ( inout ) :: self !< XML tag. integer ( I4P ) :: i , j !< Counter. call self % tag_name % free call self % tag_content % free self % pos = 0_I4P if ( allocated ( self % attribute )) then do j = 1 , size ( self % attribute , dim = 2 ) do i = 1 , size ( self % attribute , dim = 1 ) call self % attribute ( i , j )% free enddo enddo deallocate ( self % attribute ) self % attributes_number = 0_I4P endif self % indent = 0_I4P self % is_self_closing = . false . self % level = 0_I4P self % id = 0_I4P self % parent_id = 0_I4P self % children_number = 0_I4P if ( allocated ( self % child_ID )) deallocate ( self % child_ID ) endsubroutine free pure subroutine get_content ( self , name , content ) !< Return tag content of self (or its nested tags) if named *name*. !< !< @note If there is no value, the *content* string is returned deallocated. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( * ), intent ( in ) :: name !< Searched tag name. character ( len = :), allocatable , intent ( out ) :: content !< Tag content. type ( xml_tag ) :: tag !< Dummy XML tag. if ( allocated ( content )) deallocate ( content ) if ( self % tag_name % is_allocated ()) then if ( self % tag_name == name ) then if ( self % tag_content % is_allocated ()) content = self % tag_content % chars () else if ( self % tag_content % is_allocated ()) then call tag % search ( tag_name = name , source = self % tag_content % chars ()) if ( tag % tag_content % is_allocated ()) content = tag % tag_content % chars () endif endif endif endsubroutine get_content pure function is_attribute_present ( self , name ) result ( is_present ) !< Return .true. it the queried attribute name is defined, .false. otherwise. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( * ), intent ( in ) :: name !< Attribute name. logical :: is_present !< Inquire result. integer ( I4P ) :: a !< Counter. is_present = . false . if ( self % attributes_number > 0 ) then do a = 1 , self % attributes_number if ( self % attribute ( 1 , a ) == name ) then is_present = . true . exit endif enddo endif endfunction is_attribute_present elemental function is_parsed ( self ) !< Check is tag is correctly parsed, i.e. its *tag_name* is allocated. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical :: is_parsed !< Result of check. is_parsed = self % tag_name % is_allocated () endfunction is_parsed pure function name ( self ) !< Return tag name. class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( len = :), allocatable :: name !< XML tag name. name = self % tag_name % chars () endfunction name elemental subroutine parse ( self , source , tstart , tend ) !< Parse the tag contained into a source string. !< !< It is assumed that the first tag contained into the source string is parsed, the others eventually present are omitted. !< Valid syntax are: !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name>` !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\".../>` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the string. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the string. integer ( I4P ) :: tstartd !< Starting index of tag inside the string. integer ( I4P ) :: tendd !< Ending index of tag inside the string. tstartd = 0 tendd = 0 call self % parse_tag_name ( source = source , tstart = tstartd , tend = tendd ) if ( self % tag_name % is_allocated ()) then if ( index ( string = source ( tstartd : tendd ), substring = '=' ) > 0 ) call self % parse_attributes_names ( source = source ( tstartd : tendd )) if ( index ( string = source , substring = '</' // self % tag_name // '>' ) > 0 ) & tendd = index ( string = source , substring = '</' // self % tag_name // '>' ) + len ( '</' // self % tag_name // '>' ) - 1 call self % get ( source = source ( tstartd : tendd )) endif if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd endsubroutine parse elemental subroutine parse_tag_name ( self , source , tstart , tend ) !< Parse the tag name contained into a string. !< !< It is assumed that the first tag contained into the source is parsed, the others eventually present are omitted. !< Valid syntax are: !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name>` !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\".../>` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the source. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the source. integer ( I4P ) :: tstartd !< Starting index of tag inside the source. integer ( I4P ) :: tendd !< Ending index of tag inside the source. character ( len = 1 ) :: c1 !< Dummy string for parsing file. character ( len = :), allocatable :: c2 !< Dummy string for parsing file. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: s !< Counter. call self % tag_name % free tstartd = 0 tendd = 0 c = 1 Tag_Search : do while ( c <= len ( source )) c1 = source ( c : c ) if ( c1 == '<' . and . source ( c + 1 : c + 1 ) /= '/' ) then tstartd = c c2 = c1 Tag_Name : do while ( c < len ( source )) c = c + 1 ; c1 = source ( c : c ) c2 = c2 // c1 if ( c1 == '>' ) then tendd = c exit Tag_Name endif enddo Tag_Name s = index ( string = c2 , substring = ' ' ) if ( s > 0 ) then ! there are attributes self % tag_name = c2 ( 2 : s - 1 ) else if ( index ( string = c2 , substring = '/>' ) > 0 ) then ! self closing tag self % tag_name = c2 ( 2 : len ( c2 ) - 2 ) else self % tag_name = c2 ( 2 : len ( c2 ) - 1 ) endif endif exit Tag_Search endif c = c + 1 enddo Tag_Search if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd endsubroutine parse_tag_name pure subroutine set ( self , name , attribute , attributes , attributes_stream , sanitize_attributes_value , content , & pos , indent , is_content_indented , is_self_closing , id , level , parent_id , & attributes_stream_alloc , content_alloc ) !< Set tag data. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ), optional :: name !< Tag name. character ( * ), intent ( in ), optional :: attribute ( 1 :) !< Attribute name/value pair [1:2]. character ( * ), intent ( in ), optional :: attributes ( 1 :, 1 :) !< Attributes list of name/value pairs [1:2,1:]. character ( * ), intent ( in ), optional :: attributes_stream !< Attributes list of name/value pairs as stream. logical , intent ( in ), optional :: sanitize_attributes_value !< Sanitize attributes value. character ( * ), intent ( in ), optional :: content !< Tag value. integer ( I4P ), intent ( in ), optional :: pos ( 1 :) !< Characters position (in source) indexes. integer ( I4P ), intent ( in ), optional :: indent !< Number of indent-white-spaces. logical , intent ( in ), optional :: is_content_indented !< Activate value indentation. logical , intent ( in ), optional :: is_self_closing !< The tag is self closing. integer ( I4P ), intent ( in ), optional :: id !< Uniq ID. integer ( I4P ), intent ( in ), optional :: level !< Tag hierarchy level. integer ( I4P ), intent ( in ), optional :: parent_id !< Parent uniq ID. character (:), allocatable , intent ( in ), optional :: attributes_stream_alloc !< Attributes list stream, allocatable input. character (:), allocatable , intent ( in ), optional :: content_alloc !< Tag value, allocatable input. logical :: is_content_indented_ !< Activate value indentation. is_content_indented_ = . false . ; if ( present ( is_content_indented )) is_content_indented_ = is_content_indented if ( present ( name )) self % tag_name = name if ( present ( attribute )) call self % add_single_attribute ( attribute = attribute , sanitize_value = sanitize_attributes_value ) if ( present ( attributes )) call self % add_multiple_attributes ( attributes = attributes , sanitize_values = sanitize_attributes_value ) if ( present ( attributes_stream )) call self % add_stream_attributes ( attributes_stream = attributes_stream , & sanitize_values = sanitize_attributes_value ) if ( present ( pos )) self % pos = pos if ( present ( indent )) self % indent = indent if ( present ( content )) then if ( is_content_indented_ ) then self % tag_content = new_line ( 'a' ) // repeat ( ' ' , self % indent + 2 ) // content // new_line ( 'a' ) else self % tag_content = content endif endif if ( present ( is_self_closing )) self % is_self_closing = is_self_closing if ( present ( id )) self % id = id if ( present ( level )) self % level = level if ( present ( parent_id )) self % parent_id = parent_id if ( present ( attributes_stream_alloc )) then if ( allocated ( attributes_stream_alloc )) call self % add_stream_attributes ( attributes_stream = attributes_stream_alloc , & sanitize_values = sanitize_attributes_value ) endif if ( present ( content_alloc )) then if ( allocated ( content_alloc )) then if ( is_content_indented_ ) then self % tag_content = new_line ( 'a' ) // repeat ( ' ' , self % indent + 2 ) // content_alloc // new_line ( 'a' ) else self % tag_content = content_alloc endif endif endif endsubroutine set pure function self_closing_tag ( self , is_indented ) result ( tag_ ) !< Return `<tag_name.../>` self closing tag. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Flag to check if tag is indented. character ( len = :), allocatable :: tag_ !< The self closing tag string. tag_ = '<' // self % tag_name if ( self % attributes_number > 0 ) tag_ = tag_ // ' ' // self % attributes () tag_ = tag_ // '/>' if ( present ( is_indented )) then if ( is_indented ) tag_ = repeat ( ' ' , self % indent ) // tag_ endif endfunction self_closing_tag pure function start_tag ( self , is_indented ) result ( tag_ ) !< Return `<tag_name...>` start tag. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Flag to check if tag is indented. character ( len = :), allocatable :: tag_ !< The start tag string. tag_ = '<' // self % tag_name if ( self % attributes_number > 0 ) tag_ = tag_ // ' ' // self % attributes () tag_ = tag_ // '>' if ( present ( is_indented )) then if ( is_indented ) tag_ = repeat ( ' ' , self % indent ) // tag_ endif endfunction start_tag pure function stringify ( self , is_indented , is_content_indented , only_start , only_content , only_end , linearize ) result ( stringed ) !< Convert the whole tag into a string. class ( xml_tag ), intent ( in ) :: self !< XML tag. logical , intent ( in ), optional :: is_indented !< Activate content indentation. logical , intent ( in ), optional :: is_content_indented !< Activate content indentation. logical , intent ( in ), optional :: only_start !< Write only start tag. logical , intent ( in ), optional :: only_content !< Write only content. logical , intent ( in ), optional :: only_end !< Write only end tag. logical , intent ( in ), optional :: linearize !< Return a \"linearized\" string of tags without the XML hieararchy. logical :: linearize_ !< Linearize sentinel, local var. character ( len = :), allocatable :: stringed !< Output string containing the whole tag. logical :: is_content_indented_ !< Activate content indentation. logical :: only_start_ !< Write only start tag. logical :: only_content_ !< Write only content. logical :: only_end_ !< Write only end tag. linearize_ = . false . ; if ( present ( linearize )) linearize_ = linearize if ( linearize_ ) then stringed = '' stringed = stringed // 'name:            \"' // self % tag_name // '\"' // new_line ( 'a' ) if ( self % attributes_number > 0 ) stringed = stringed // 'attributes:      \"' // self % attributes () // '\"' // new_line ( 'a' ) stringed = stringed // 'char pos indexes:\"' // trim ( str ( self % pos )) // '\"' // new_line ( 'a' ) stringed = stringed // 'content:         \"' // self % tag_content // '\"' // new_line ( 'a' ) stringed = stringed // 'indent:          \"' // trim ( str ( self % indent )) // '\"' // new_line ( 'a' ) stringed = stringed // 'is self closing: \"' // trim ( str ( self % is_self_closing )) // '\"' // new_line ( 'a' ) stringed = stringed // 'level:           \"' // trim ( str ( self % level )) // '\"' // new_line ( 'a' ) stringed = stringed // 'id:              \"' // trim ( str ( self % id )) // '\"' // new_line ( 'a' ) stringed = stringed // 'parent id:       \"' // trim ( str ( self % parent_id )) // '\"' // new_line ( 'a' ) stringed = stringed // 'children number: \"' // trim ( str ( self % children_number )) // '\"' // new_line ( 'a' ) if ( allocated ( self % child_id )) stringed = stringed // 'children ids:    \"' // trim ( str ( self % child_id )) // '\"' // new_line ( 'a' ) else is_content_indented_ = . false . ; if ( present ( is_content_indented )) is_content_indented_ = is_content_indented only_start_ = . false . ; if ( present ( only_start )) only_start_ = only_start only_content_ = . false . ; if ( present ( only_content )) only_content_ = only_content only_end_ = . false . ; if ( present ( only_end )) only_end_ = only_end if ( only_start_ ) then stringed = self % start_tag ( is_indented = is_indented ) elseif ( only_content_ ) then if ( self % tag_content % is_allocated ()) then if ( is_content_indented_ ) then stringed = repeat ( ' ' , self % indent + 2 ) // self % tag_content else stringed = self % tag_content % chars () endif endif elseif ( only_end_ ) then stringed = self % end_tag ( is_indented = is_indented ) else stringed = '' if ( self % tag_name % is_allocated ()) then if ( self % is_self_closing ) then stringed = self % self_closing_tag ( is_indented = is_indented ) else stringed = self % start_tag ( is_indented = is_indented ) if ( self % tag_content % is_allocated ()) then if ( is_content_indented_ ) then stringed = stringed // new_line ( 'a' ) // repeat ( ' ' , self % indent + 2 ) // & self % tag_content // new_line ( 'a' ) // repeat ( ' ' , self % indent ) else stringed = stringed // self % tag_content endif endif stringed = stringed // self % end_tag () endif endif endif endif endfunction stringify subroutine write_tag ( self , unit , is_indented , is_content_indented , form , end_record , only_start , only_content , only_end , & iostat , iomsg ) !< Write tag to unit file. class ( xml_tag ), intent ( in ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: unit !< File unit. logical , intent ( in ), optional :: is_indented !< Activate content indentation. logical , intent ( in ), optional :: is_content_indented !< Activate content indentation. character ( * ), intent ( in ), optional :: form !< Format. character ( * ), intent ( in ), optional :: end_record !< Ending record. logical , intent ( in ), optional :: only_start !< Write only start tag. logical , intent ( in ), optional :: only_content !< Write only content. logical , intent ( in ), optional :: only_end !< Write only end tag. integer ( I4P ), intent ( out ), optional :: iostat !< IO status. character ( * ), intent ( out ), optional :: iomsg !< IO message. type ( string ) :: form_ !< Format. type ( string ) :: end_record_ !< Ending record. integer ( I4P ) :: iostat_ !< IO status. character ( 500 ) :: iomsg_ !< IO message. form_ = 'UNFORMATTED' if ( present ( form )) then form_ = form form_ = form_ % upper () endif end_record_ = '' ; if ( present ( end_record )) end_record_ = end_record select case ( form_ % chars ()) case ( 'UNFORMATTED' ) write ( unit = unit , iostat = iostat_ , iomsg = iomsg_ ) self % stringify ( is_indented = is_indented , & is_content_indented = is_content_indented , & only_start = only_start , & only_content = only_content , & only_end = only_end ) // end_record_ case ( 'FORMATTED' ) write ( unit = unit , fmt = '(A)' , iostat = iostat_ , iomsg = iomsg_ ) self % stringify ( is_indented = is_indented , & is_content_indented = is_content_indented , & only_start = only_start , & only_content = only_content , & only_end = only_end ) // end_record_ endselect if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_tag ! private methods pure subroutine add_single_attribute ( self , attribute , sanitize_value ) !< Add one attribute name/value pair. !< !< @note Leading and trailing white spaces are trimmed out by attribute's name. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: attribute ( 1 :) !< Attribute name/value pair [1:2]. logical , intent ( in ), optional :: sanitize_value !< Sanitize attribute value. type ( string ), allocatable :: new_attribute (:,:) !< Temporary storage for attributes. logical :: sanitize_value_ !< Sanitize attribute value. logical :: is_updated !< Flag to check if the attribute has been updeted. integer ( I4P ) :: a !< Counter. sanitize_value_ = . false . ; if ( present ( sanitize_value )) sanitize_value_ = sanitize_value if ( self % attributes_number > 0 ) then is_updated = . false . update_if_already_present : do a = 1 , self % attributes_number if ( self % attribute ( 1 , a ) == attribute ( 1 )) then if ( sanitize_value_ ) then self % attribute ( 2 , a ) = trim ( adjustl ( attribute ( 2 ))) else self % attribute ( 2 , a ) = attribute ( 2 ) endif is_updated = . true . exit update_if_already_present endif enddo update_if_already_present if (. not . is_updated ) then allocate ( new_attribute ( 1 : 2 , 1 : self % attributes_number + 1 )) new_attribute ( 1 : 2 , 1 : self % attributes_number ) = self % attribute new_attribute ( 1 , self % attributes_number + 1 ) = trim ( adjustl ( attribute ( 1 ))) if ( sanitize_value_ ) then new_attribute ( 2 , self % attributes_number + 1 ) = trim ( adjustl ( attribute ( 2 ))) else new_attribute ( 2 , self % attributes_number + 1 ) = attribute ( 2 ) endif call move_alloc ( from = new_attribute , to = self % attribute ) self % attributes_number = self % attributes_number + 1 endif else call self % alloc_attributes ( Na = 1 ) self % attribute ( 1 , 1 ) = trim ( adjustl ( attribute ( 1 ))) if ( sanitize_value_ ) then self % attribute ( 2 , 1 ) = trim ( adjustl ( attribute ( 2 ))) else self % attribute ( 2 , 1 ) = attribute ( 2 ) endif endif endsubroutine add_single_attribute pure subroutine add_multiple_attributes ( self , attributes , sanitize_values ) !< Add list of attributes name/value pairs. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: attributes ( 1 :, 1 :) !< Attribute name/value pair list [1:2,1:]. logical , intent ( in ), optional :: sanitize_values !< Sanitize attribute values. integer ( I4P ) :: a !< Counter. do a = 1 , size ( attributes , dim = 2 ) ! not efficient: many reallocation, but safe call self % add_single_attribute ( attribute = attributes ( 1 :, a ), sanitize_value = sanitize_values ) enddo endsubroutine add_multiple_attributes pure subroutine add_stream_attributes ( self , attributes_stream , sanitize_values ) !< Add list of attributes name/value pairs passed as stream. !< !< @note The character `=` cannot compare into the attributes names of values. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: attributes_stream !< Attribute name/value pair list passed as stream. logical , intent ( in ), optional :: sanitize_values !< Sanitize attribute values. type ( string ) :: attributes_string !< Attribute name/value pair list as string. type ( string ) :: tokens ( 1 : 3 ) !< Attributes tokenized by `=`. type ( string ) :: attribute ( 1 : 2 ) !< Attribute name/value pair. logical :: continue_to_parse !< Sentinel to stop attributes stream parsing. integer ( I4P ) :: max_chars !< Counter. attributes_string = attributes_stream continue_to_parse = . true . do while ( continue_to_parse ) tokens = attributes_string % partition ( sep = '=' ) attribute ( 1 ) = trim ( adjustl ( tokens ( 1 ))) if ( attribute ( 1 ) /= '' ) then tokens ( 3 ) = tokens ( 3 )% slice ( istart = tokens ( 3 )% index ( '\"' ) + 1 , iend = tokens ( 3 )% len ()) attribute ( 2 ) = tokens ( 3 )% slice ( istart = 1 , iend = tokens ( 3 )% index ( '\"' ) - 1 ) tokens ( 3 ) = tokens ( 3 )% slice ( istart = tokens ( 3 )% index ( '\"' ) + 1 , iend = tokens ( 3 )% len ()) max_chars = max ( attribute ( 1 )% len (), attribute ( 2 )% len ()) attribute ( 1 ) = attribute ( 1 )% fill ( width = max_chars , right = . true ., filling_char = ' ' ) attribute ( 2 ) = attribute ( 2 )% fill ( width = max_chars , right = . true ., filling_char = ' ' ) call self % add_single_attribute ( attribute = [ attribute ( 1 ) // '' , attribute ( 2 ) // '' ], sanitize_value = sanitize_values ) if ( tokens ( 3 )% index ( '=' ) > 0 ) then attributes_string = tokens ( 3 ) else continue_to_parse = . false . endif else continue_to_parse = . false . endif enddo endsubroutine add_stream_attributes elemental subroutine alloc_attributes ( self , Na ) !< Allocate (prepare for filling) dynamic memory of attributes. class ( xml_tag ), intent ( inout ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: Na !< Number of attributes. if ( allocated ( self % attribute )) then call self % attribute % free deallocate ( self % attribute ) endif allocate ( self % attribute ( 1 : 2 , 1 : Na )) self % attributes_number = Na endsubroutine alloc_attributes pure subroutine delete_content ( self ) !< Delete tag content. class ( xml_tag ), intent ( inout ) :: self !< XML tag. call self % tag_content % free endsubroutine delete_content pure subroutine delete_single_attribute ( self , name ) !< Delete one attribute name/value pair. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: name !< Attribute name. type ( string ), allocatable :: new_attribute (:,:) !< Temporary storage for attributes. integer ( I4P ) :: a !< Counter. if ( self % attributes_number > 0 ) then search_tag : do a = 1 , self % attributes_number if ( self % attribute ( 1 , a ) == name ) then if ( self % attributes_number > 1 ) then allocate ( new_attribute ( 1 : 2 , 1 : self % attributes_number - 1 )) if ( a == 1 ) then new_attribute (:, a :) = self % attribute (:, a + 1 :) elseif ( a == self % attributes_number ) then new_attribute (:, : a - 1 ) = self % attribute (:, : a - 1 ) else new_attribute (:, : a - 1 ) = self % attribute (:, : a - 1 ) new_attribute (:, a :) = self % attribute (:, a + 1 :) endif call move_alloc ( from = new_attribute , to = self % attribute ) else call self % attribute % free deallocate ( self % attribute ) endif self % attributes_number = self % attributes_number - 1 exit search_tag endif enddo search_tag endif endsubroutine delete_single_attribute pure subroutine delete_multiple_attributes ( self , name ) !< Delete list of attributes name/value pairs. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: name ( 1 :) !< Attributes names. integer ( I4P ) :: a !< Counter. do a = 1 , size ( name , dim = 1 ) call self % delete_single_attribute ( name = name ( a )) enddo endsubroutine delete_multiple_attributes elemental subroutine get ( self , source ) !< Get the tag content and attributes from source after tag_name and attributes names have been set. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. call self % get_value ( source = source ) call self % get_attributes ( source = source ) ! call self%get_nested() endsubroutine get elemental subroutine get_attributes ( self , source ) !< Get the attributes values from source after tag_name and attributes names have been set. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. integer :: a !< Counter. integer :: c1 !< Counter. integer :: c2 !< Counter. if ( index ( string = source , substring = '<' // self % tag_name ) > 0 ) then if ( self % attributes_number > 0 ) then ! parsing attributes do a = 1 , self % attributes_number c1 = index ( string = source , substring = self % attribute ( 1 , a ) // '=\"' ) + self % attribute ( 1 , a )% len () + 2 if ( c1 > self % attribute ( 1 , a )% len () + 2 ) then c2 = index ( string = source ( c1 :), substring = '\"' ) if ( c2 > 0 ) then self % attribute ( 2 , a ) = source ( c1 : c1 + c2 - 2 ) else call self % attribute ( 2 , a )% free endif else call self % attribute ( 2 , a )% free endif enddo endif endif endsubroutine get_attributes elemental subroutine get_value ( self , source ) !< Get the tag value from source after tag_name has been set. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. integer :: c1 !< Counter. integer :: c2 !< Counter. call self % tag_content % free self % is_self_closing = . false . if ( index ( string = source , substring = '<' // self % tag_name ) > 0 ) then c2 = index ( string = source , substring = '</' // self % tag_name // '>' ) if ( c2 > 0 ) then ! parsing tag value c1 = index ( string = source , substring = '>' ) if ( c1 + 1 < c2 - 1 ) self % tag_content = source ( c1 + 1 : c2 - 1 ) else self % is_self_closing = . true . endif endif endsubroutine get_value elemental subroutine parse_attributes_names ( self , source ) !< Parse the tag attributes names contained into a string. !< !< Valid syntax is: !< + `att1=\"att1 val\" att2=\"att2 val\"...` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. character ( len = :), allocatable :: att !< Dummy string for parsing file. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: Na !< Counter. Na = 0 c = 1 att_count : do while ( c <= len ( source )) if ( source ( c : c ) == '=' ) Na = Na + 1 c = c + 1 enddo att_count if ( Na > 0 ) then call self % alloc_attributes ( Na = Na ) c = index ( string = source , substring = ' ' ) att = source ( c :) c = 1 a = 1 att_search : do while ( c <= len ( att )) if ( att ( c : c ) == '=' ) then s = max ( 0 , index ( string = att , substring = ' ' )) self % attribute ( 1 , a ) = trim ( adjustl ( att ( s + 1 : c - 1 ))) att = att ( c + 1 :) c = 1 a = a + 1 endif c = c + 1 enddo att_search endif endsubroutine parse_attributes_names elemental subroutine search ( self , tag_name , source , tstart , tend ) !< Search tag named *tag_name* into a string and, in case it is found, store into self. !< !< @note If *tag_name* is not found, self is returned empty. class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: tag_name !< Searched tag name. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the source. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the source. type ( xml_tag ) :: tag !< Dummy XML tag. integer ( I4P ) :: tstart_ !< Starting index of tag inside the source, local variable. integer ( I4P ) :: tend_ !< Ending index of tag inside the source, local variable. logical :: found !< Flag for inquiring search result. integer ( I4P ) :: tstart_c !< Starting index of tag inside the current slice of source. integer ( I4P ) :: tend_c !< Starting index of tag inside the current slice of source. integer ( I4P ) :: i call self % free self % tag_name = tag_name tstart_ = 1 tend_ = 0 found = . false . tstart_c = 0 tend_c = 0 tag_search : do call tag % parse ( source = source ( tend_ + 1 :), tstart = tstart_c , tend = tend_c ) tstart_ = tstart_ + tend_ tend_ = tend_ + tend_c if ( tstart_c == 0. and . tend_c == 0 ) then exit tag_search ! no tag found else if ( tag % tag_name % is_allocated ()) then if ( tag % tag_name == self % tag_name ) found = . true . endif endif if ( found ) exit tag_search enddo tag_search if ( found ) then self = tag else call self % free endif if ( present ( tstart )) tstart = tstart_ if ( present ( tend )) tend = tend_ endsubroutine search ! assignment (=) elemental subroutine assign_tag ( lhs , rhs ) !< Assignment between two tags. class ( xml_tag ), intent ( inout ) :: lhs !< Left hand side. type ( xml_tag ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: a !< Counter. call lhs % free if ( rhs % tag_name % is_allocated ()) lhs % tag_name = rhs % tag_name if ( rhs % tag_content % is_allocated ()) lhs % tag_content = rhs % tag_content lhs % pos = rhs % pos if ( rhs % attributes_number > 0 ) then allocate ( lhs % attribute ( 1 : 2 , 1 : rhs % attributes_number )) do a = 1 , rhs % attributes_number lhs % attribute ( 1 : 2 , a ) = rhs % attribute ( 1 : 2 , a ) enddo endif lhs % attributes_number = rhs % attributes_number lhs % indent = rhs % indent lhs % is_self_closing = rhs % is_self_closing lhs % level = rhs % level lhs % id = rhs % id lhs % parent_id = rhs % parent_id lhs % children_number = rhs % children_number if ( allocated ( rhs % child_ID )) lhs % child_ID = rhs % child_ID endsubroutine assign_tag ! finalize elemental subroutine finalize ( tag ) !< Free dynamic memory when finalizing. type ( xml_tag ), intent ( inout ) :: tag !< XML tag. call tag % free endsubroutine finalize endmodule foxy_xml_tag","tags":"","url":"sourcefile/foxy_xml_tag.f90.html"},{"title":"foxy_test_delete_attributes.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_delete_attributes.f90~~EfferentGraph sourcefile~foxy_test_delete_attributes.f90 foxy_test_delete_attributes.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_delete_attributes.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_delete_attributes !< FoXy test. use foxy , only : xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 4 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'delete \"y\" attribute' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = \"y\" ) parsed = a_tag % stringify () source = '<first x=\"1\" z=\"2\">lorem ipsum...</first>' test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'delete \"x\" attribute' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = \"x\" ) parsed = a_tag % stringify () source = '<first y=\"c\" z=\"2\">lorem ipsum...</first>' test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) print \"(A)\" , 'delete \"z\" attribute' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = \"z\" ) parsed = a_tag % stringify () source = '<first x=\"1\" y=\"c\">lorem ipsum...</first>' test_passed ( 3 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 3 ) print \"(A)\" , 'delete \"x\" \"z\" attributes' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_attributes ( name = [ \"z\" , \"x\" ]) parsed = a_tag % stringify () source = '<first y=\"c\">lorem ipsum...</first>' test_passed ( 4 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 4 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_delete_attributes","tags":"","url":"sourcefile/foxy_test_delete_attributes.f90.html"},{"title":"foxy_test_write_tag.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_write_tag.f90~~EfferentGraph sourcefile~foxy_test_write_tag.f90 foxy_test_write_tag.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_write_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_write_tag !< FoXy test. use foxy implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. type ( xml_file ) :: xfile !< XML file handler. integer :: xunit !< XML file unit. logical :: test_passed ( 3 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' , status = 'REPLACE' ) print \"(A)\" , 'write tag' call a_tag % write ( unit = xunit , form = 'unformatted' ) close ( unit = xunit ) call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">' // new_line ( 'a' ) // '  lorem ipsum...' // new_line ( 'a' ) // '</first>' print \"(A)\" , source a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' , status = 'REPLACE' ) print \"(A)\" , 'write tag' call a_tag % write ( unit = xunit , form = 'unformatted' , is_indented = . true ., is_content_indented = . true .) close ( unit = xunit ) call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 2 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 2 ) open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' , status = 'REPLACE' ) print \"(A)\" , 'write tag' call a_tag % write ( unit = xunit , form = 'unformatted' , is_indented = . true ., only_start = . true ., end_record = new_line ( 'a' )) call a_tag % write ( unit = xunit , form = 'unformatted' , is_content_indented = . true ., only_content = . true ., end_record = new_line ( 'a' )) call a_tag % write ( unit = xunit , form = 'unformatted' , is_indented = . true ., only_end = . true .) close ( unit = xunit ) call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 3 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 3 ) open ( newunit = xunit , file = 'parse_file_simple.xml' ) close ( unit = xunit , status = 'DELETE' ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_write_tag","tags":"","url":"sourcefile/foxy_test_write_tag.f90.html"},{"title":"foxy_test_parse_string_simple.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_parse_string_simple.f90~~EfferentGraph sourcefile~foxy_test_parse_string_simple.f90 foxy_test_parse_string_simple.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_parse_string_simple.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_parse_string_simple !< FoXy test. use foxy , only : xml_file implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested level=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '  <nested2 level=\"1\">' // new_line ( 'a' ) // & '    <nested3 level=\"2\">Nested tag at level 2</nested3>' // new_line ( 'a' ) // & '  </nested2>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source print \"(A)\" , 'Parsing file' call xfile % parse ( string = source ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_parse_string_simple","tags":"","url":"sourcefile/foxy_test_parse_string_simple.f90.html"},{"title":"foxy_test_delete_content.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_delete_content.f90~~EfferentGraph sourcefile~foxy_test_delete_content.f90 foxy_test_delete_content.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_delete_content.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_delete_content !< FoXy test. use foxy , only : xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'delete content' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) call a_tag % delete_content () parsed = a_tag % stringify () source = '<first x=\"1\" y=\"c\" z=\"2\"></first>' test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_delete_content","tags":"","url":"sourcefile/foxy_test_delete_content.f90.html"},{"title":"foxy_test_parse_string_nested_tags.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_parse_string_nested_tags.f90~~EfferentGraph sourcefile~foxy_test_parse_string_nested_tags.f90 foxy_test_parse_string_nested_tags.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_parse_string_nested_tags.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_parse_string_nested_tags !< FoXy test. use foxy , only : xml_file implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. logical :: test_passed ( 1 ) !< List of passed tests. integer f test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<tag1 level=\"1\">lorem ipsum...</tag1>' // new_line ( 'a' ) // & '<tag2 level=\"1\" type=\"self_closing\"/>' // new_line ( 'a' ) // & '<tag3 level=\"1\">bye</tag3>' // new_line ( 'a' ) // & '<tag4 level=\"1\">bye bye Mrs. Robinson</tag4>' // new_line ( 'a' ) // & '<tag4 level=\"1\" type=\"repeat\">here we are, again</tag4>' // new_line ( 'a' ) // & '<tag4 level=\"1\" type=\"repeat_bis\">and again</tag4>' // new_line ( 'a' ) // & '<tag4 level=\"1\" type=\"repeat_tris\">forever</tag4>' // new_line ( 'a' ) // & '<tag5>' // new_line ( 'a' ) // & '  <tag6 level=\"2\">content of tag6</tag6>' // new_line ( 'a' ) // & '  <tag7 level=\"2\">' // new_line ( 'a' ) // & '    <tag7 level=\"3\" type=\"nested\">content of tag7 nested</tag7>' // new_line ( 'a' ) // & '    <tag8 level=\"3\">content of tag8</tag8>' // new_line ( 'a' ) // & '    <tag7 level=\"3\" type=\"nested repeat\">content of tag7 nested repeat</tag7>' // new_line ( 'a' ) // & '    <tag9 level=\"3\">' // new_line ( 'a' ) // & '      <tag10 level=\"4\">content of tag10</tag10>' // new_line ( 'a' ) // & '    </tag9>' // new_line ( 'a' ) // & '    <tag7 level=\"3\" type=\"nested\">' // new_line ( 'a' ) // & '      <tag7 level=\"4\" type=\"nested double\">content of tag7 nested double</tag7>' // new_line ( 'a' ) // & '    </tag7>' // new_line ( 'a' ) // & '  </tag7>' // new_line ( 'a' ) // & '</tag5>' // new_line ( 'a' ) // & '<tag11 level=\"1\" type=\"self_closing\"/>' print \"(A)\" , source print \"(A)\" , 'Parsing file' call xfile % parse ( string = source ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) print \"(A)\" , 'Parsed data linearized' print \"(A)\" , xfile % stringify ( linearize = . true .) open ( newunit = f , file = 'source.xml' ) write ( f , '(A)' ) source close ( f ) open ( newunit = f , file = 'parsed.xml' ) write ( f , '(A)' ) parsed close ( f ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_parse_string_nested_tags","tags":"","url":"sourcefile/foxy_test_parse_string_nested_tags.f90.html"},{"title":"foxy_test_indent_tag.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_indent_tag.f90~~EfferentGraph sourcefile~foxy_test_indent_tag.f90 foxy_test_indent_tag.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_indent_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_indent_tag !< FoXy test. use foxy , only : xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . print \"(A)\" , 'source' source = '  <first>lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , indent = 2 ) parsed = a_tag % stringify ( is_indented = . true .) test_passed ( 1 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'source' source = '  <first>' // new_line ( 'a' ) // & '    lorem ipsum...' // new_line ( 'a' ) // & '  </first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , indent = 2 ) parsed = a_tag % stringify ( is_indented = . true ., is_content_indented = . true .) test_passed ( 2 ) = trim ( adjustl ( source )) == trim ( adjustl ( parsed )) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_indent_tag","tags":"","url":"sourcefile/foxy_test_indent_tag.f90.html"},{"title":"foxy_xml_file.f90 – FoXy","text":"FoXy XML file class. This file depends on sourcefile~~foxy_xml_file.f90~~EfferentGraph sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~foxy_xml_file.f90~~AfferentGraph sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_test_add_attributes.f90 foxy_test_add_attributes.f90 sourcefile~foxy_test_add_attributes.f90->sourcefile~foxy.f90 sourcefile~foxy_test_add_tag.f90 foxy_test_add_tag.f90 sourcefile~foxy_test_add_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_create_tag.f90 foxy_test_create_tag.f90 sourcefile~foxy_test_create_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_delete_attributes.f90 foxy_test_delete_attributes.f90 sourcefile~foxy_test_delete_attributes.f90->sourcefile~foxy.f90 sourcefile~foxy_test_delete_content.f90 foxy_test_delete_content.f90 sourcefile~foxy_test_delete_content.f90->sourcefile~foxy.f90 sourcefile~foxy_test_delete_tag.f90 foxy_test_delete_tag.f90 sourcefile~foxy_test_delete_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_indent_tag.f90 foxy_test_indent_tag.f90 sourcefile~foxy_test_indent_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_test_parse_file_simple.f90 foxy_test_parse_file_simple.f90 sourcefile~foxy_test_parse_file_simple.f90->sourcefile~foxy.f90 sourcefile~foxy_test_parse_string_nested_tags.f90 foxy_test_parse_string_nested_tags.f90 sourcefile~foxy_test_parse_string_nested_tags.f90->sourcefile~foxy.f90 sourcefile~foxy_test_parse_string_simple.f90 foxy_test_parse_string_simple.f90 sourcefile~foxy_test_parse_string_simple.f90->sourcefile~foxy.f90 sourcefile~foxy_test_write_tag.f90 foxy_test_write_tag.f90 sourcefile~foxy_test_write_tag.f90->sourcefile~foxy.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy XML file class. module foxy_xml_file !< FoXy XML file class. use foxy_xml_tag , only : xml_tag use penf implicit none private type , public :: xml_file !< XML file class. private type ( xml_tag ), allocatable :: tag (:) !< XML tags array. integer ( I4P ) :: nt = 0_I4P !< Number of XML tags. contains ! public methods procedure , pass ( self ) :: add_tag !< Add tag to XML file. procedure , pass ( self ) :: content !< Return tag content of tag named *name*. procedure , pass ( self ) :: delete_tag !< Add tag from XML file. procedure , pass ( self ) :: free !< Free dynamic memory. procedure , pass ( self ) :: parse !< Parse xml file. procedure , pass ( self ) :: stringify !< Convert the whole file data into a string. ! private methods procedure , pass ( self ), private :: add_child !< Add child ID to tag children list. procedure , pass ( self ), private :: parse_from_string !< Parse xml data from string. procedure , pass ( self ), private :: stringify_recursive !< Convert recursively tags with children into a string. ! operators final :: finalize !< Free dynamic memory when finalizing. endtype xml_file contains ! public methods elemental subroutine add_tag ( self , tag ) !< Add tag to XML file. class ( xml_file ), intent ( inout ) :: self !< XML file. type ( xml_tag ), intent ( in ) :: tag !< XML tag. type ( xml_tag ), allocatable :: tag_new (:) !< New (extended) tags array. if ( self % nt > 0_I4P ) then allocate ( tag_new ( 1 : self % nt + 1 )) tag_new ( 1 : self % nt ) = self % tag ( 1 : self % nt ) tag_new ( self % nt + 1 ) = tag else allocate ( tag_new ( 1 : 1 )) tag_new ( 1 ) = tag endif call move_alloc ( from = tag_new , to = self % tag ) self % nt = self % nt + 1 endsubroutine add_tag pure function content ( self , name ) !< Return tag content of tag named *name*. !< !< @note If there is no value, the *tag_content* string is returned empty, but allocated. class ( xml_file ), intent ( in ) :: self !< XML file. character ( * ), intent ( in ) :: name !< Tag name. character ( len = :), allocatable :: content !< Tag content. integer ( I4P ) :: t !< Counter. if ( allocated ( content )) deallocate ( content ) if ( self % nt > 0 ) then do t = 1 , self % nt call self % tag ( t )% get_content ( name = name , content = content ) if ( allocated ( content )) exit enddo endif if (. not . allocated ( content )) content = '' endfunction content elemental subroutine delete_tag ( self , name ) !< Delete tag from XML file. class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), intent ( in ) :: name !< XML tag name. type ( xml_tag ), allocatable :: tag_new (:) !< New (extended) tags array. integer ( I4P ) :: t !< Counter. if ( self % nt > 0_I4P ) then do t = 1 , self % nt if ( name == self % tag ( t )% name ()) then allocate ( tag_new ( 1 : self % nt - 1 )) if ( t == 1 ) then tag_new ( t :) = self % tag ( t + 1 :) elseif ( t == self % nt ) then tag_new (: t - 1 ) = self % tag (: t - 1 ) else tag_new (: t - 1 ) = self % tag (: t - 1 ) tag_new ( t :) = self % tag ( t + 1 :) endif call move_alloc ( from = tag_new , to = self % tag ) self % nt = self % nt - 1 exit endif enddo endif endsubroutine delete_tag elemental subroutine free ( self ) !< Free dynamic memory. class ( xml_file ), intent ( inout ) :: self !< XML file. if ( allocated ( self % tag )) then call self % tag % free deallocate ( self % tag ) endif self % nt = 0_I4P endsubroutine free subroutine parse ( self , string , filename ) !< Parse xml data from string or file. !< XML data is linearized, a DOM structured is used. !< !< @note Self data are free before trying to parse new xml data: all previously parsed data are lost. class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), optional , intent ( in ) :: string !< String containing xml data. character ( * ), optional , intent ( in ) :: filename !< File name containing xml data. character ( len = :), allocatable :: source !< String containing xml data. call self % free if ( present ( string )) then call self % parse_from_string ( source_string = string ) elseif ( present ( filename )) then source = load_file_as_stream ( filename = filename , fast_read = . true .) call self % parse_from_string ( source_string = source ) endif endsubroutine parse pure function stringify ( self , linearize ) result ( string ) !< Convert the whole file data into a string. class ( xml_file ), intent ( in ) :: self !< XML file. logical , intent ( in ), optional :: linearize !< Return a \"linearized\" string of tags without the XML hieararchy. logical :: linearize_ !< Linearize sentinel, local var. character ( len = :), allocatable :: string !< Output string containing the whole xml file. character ( len = :), allocatable :: tag_string !< Output string containing the current tag. integer ( I4P ) :: t !< Counter. logical , allocatable :: is_done (:) !< List of stringified tags. linearize_ = . false . ; if ( present ( linearize )) linearize_ = linearize string = '' if ( linearize_ ) then if ( self % nt > 0 ) then do t = 1 , self % nt string = string // self % tag ( t )% stringify ( linearize = . true .) // new_line ( 'a' ) enddo endif else if ( self % nt > 0 ) then allocate ( is_done ( self % nt )) ; is_done = . false . do t = 1 , self % nt if ( is_done ( t )) cycle if ( self % tag ( t )% children_number > 0 ) then tag_string = '' call self % stringify_recursive ( tag = self % tag ( t ), is_done = is_done , tag_string = tag_string ) if ( tag_string ( 1 : 1 ) == new_line ( 'a' )) tag_string = tag_string ( 2 :) else tag_string = self % tag ( t )% stringify ( is_indented = . true .) endif string = string // tag_string // new_line ( 'a' ) is_done ( t ) = . true . enddo endif endif if ( string ( len ( string ): len ( string )) == new_line ( 'a' )) string = string (: len ( string ) - 1 ) endfunction stringify ! private methods pure subroutine add_child ( self , parent_id , child_id ) !< Add child ID to tag children list. class ( xml_file ), intent ( inout ) :: self !< XML file handler. integer ( I4P ), intent ( in ) :: child_id !< Child ID. integer ( I4P ), intent ( in ) :: parent_id !< Parent ID. if ( parent_id > 0 . and . parent_id <= self % nt ) call self % tag ( parent_id )% add_child_id ( child_id = child_id ) endsubroutine add_child pure subroutine parse_from_string ( self , source_string ) !< Parse xml data from a chunk of source string (file stringified for IO on device). class ( xml_file ), intent ( inout ) :: self !< XML file handler. character ( * ), intent ( in ) :: source_string !< String containing xml data. integer ( I4P ) :: pos , start_pos , end_pos , end_content_pos !< Position indexes. character (:), allocatable :: tag_name !< Tag name buffer. character (:), allocatable :: attributes_str !< Tag attributes string buffer. character (:), allocatable :: tag_content !< Tag content string buffer. integer ( I4P ) :: current_level !< Nesting level counter. logical :: is_closing_tag !< Sentinel for closing tag. logical :: is_self_closing !< Sentinel for self closing tag. type ( xml_tag ) :: tag !< XML tag handler. integer ( I4P ) :: parent_id !< Uniq parent tag ID. integer ( I4P ), allocatable :: parent_stack (:) !< Stack of parents ID. call self % free pos = 1_I4P current_level = 0_I4P allocate ( parent_stack ( 1 )) parent_stack = 0_I4P do while ( pos <= len_trim ( source_string )) ! next tag start start_pos = index ( source_string ( pos :), '<' ) if ( start_pos == 0 ) exit start_pos = pos + start_pos - 1 ! skip comment, XML header if ( start_pos + 3 <= len_trim ( source_string )) then if ( source_string ( start_pos : start_pos + 3 ) == '<!--' . or . source_string ( start_pos : start_pos + 1 ) == '<?' ) then end_pos = index ( source_string ( start_pos + 1 :), '>' ) if ( end_pos == 0 ) exit pos = start_pos + end_pos + 1 cycle endif endif ! close current tag end_pos = index ( source_string ( start_pos :), '>' ) if ( end_pos == 0 ) exit end_pos = start_pos + end_pos - 1 ! parse tag call parse_tag_name ( tag_str = source_string ( start_pos : end_pos ), & tag_name = tag_name , & attributes_str = attributes_str , & is_closing = is_closing_tag , & is_self_closing = is_self_closing ) if ( allocated ( tag_name )) then if ( is_closing_tag ) then current_level = current_level - 1 else ! add new tag to XML tags list call tag % free call self % add_tag ( tag = tag ) current_level = current_level + 1 ! get parent/child id if ( current_level > 1 ) then if ( parent_stack ( current_level - 1 ) > 0 ) then parent_id = parent_stack ( current_level - 1 ) call self % add_child ( parent_id = parent_stack ( current_level - 1 ), child_id = self % nt ) endif elseif ( current_level == 1 ) then parent_id = 0_I4P endif ! parent_stack(current_level) = self%nt if ( current_level == 1 ) then parent_stack ( 1 ) = self % nt else if ( current_level > 1 ) parent_stack = [ parent_stack ( 1 : current_level - 1 ), self % nt ] endif end_content_pos = - 1 ! initialize position for self closing tag if (. not . is_self_closing ) then ! get tag content call get_tag_content ( source = source_string , tag_name = tag_name , start_pos = end_pos + 1 , content = tag_content , & end_pos = end_content_pos ) endif call self % tag ( self % nt )% set ( name = tag_name , & sanitize_attributes_value = . true ., & pos = [ start_pos , end_pos , end_content_pos ], & indent = ( current_level - 1 ) * 2 , & is_self_closing = is_self_closing , & id = self % nt , & level = current_level , & parent_id = parent_id , & attributes_stream_alloc = attributes_str , & content_alloc = tag_content ) if ( is_self_closing ) current_level = current_level - 1 endif endif pos = end_pos + 1 enddo endsubroutine parse_from_string recursive pure subroutine stringify_recursive ( self , tag , is_done , tag_string ) !< Convert recursively tags with children into a string. class ( xml_file ), intent ( in ) :: self !< XML file. type ( xml_tag ), intent ( in ) :: tag !< XML tag with children. logical , intent ( inout ) :: is_done (:) !< List of stringified tags. character ( len = :), allocatable , intent ( inout ) :: tag_string !< Output string containing the current tag. integer ( I4P ) :: t !< Counter. if ( tag % children_number > 0 ) then tag_string = tag_string // new_line ( 'a' ) // tag % stringify ( is_indented = . true ., only_start = . true .) do t = 1 , tag % children_number call self % stringify_recursive ( tag = self % tag ( tag % child_id ( t )), is_done = is_done , tag_string = tag_string ) is_done ( tag % child_id ( t )) = . true . enddo tag_string = tag_string // new_line ( 'a' ) // tag % stringify ( is_indented = . true ., only_end = . true .) else tag_string = tag_string // new_line ( 'a' ) // tag % stringify ( is_indented = . true .) endif endsubroutine stringify_recursive ! operators subroutine finalize ( self ) !< Free dynamic memory when finalizing. type ( xml_file ), intent ( inout ) :: self !< XML file. call self % free endsubroutine finalize ! non TBP pure subroutine find_matching_end_tag ( source , start_pos , tag_name , end_pos ) character ( * ), intent ( in ) :: source !< Source containing tag content. character ( * ), intent ( in ) :: tag_name !< Tag name. integer ( I4P ), intent ( in ) :: start_pos !< Start tag content position. integer ( I4P ), intent ( out ) :: end_pos !< End tag position. character (:), allocatable :: open_tag !< Open tag. character (:), allocatable :: end_tag !< End tag. integer ( I4P ) :: pos , pos_tmp ( 2 ) !< Position counter. integer ( I4P ) :: tag_count !< Tags counter. open_tag = '<' // trim ( tag_name ) end_tag = '</' // trim ( tag_name ) // '>' tag_count = 1 pos = start_pos end_pos = 0 ! search for next open tag with the same name pos_tmp ( 1 ) = index ( source ( pos :), trim ( open_tag )) ! relative position pos_tmp ( 2 ) = index ( source ( pos :), trim ( end_tag )) ! relative position if ( pos_tmp ( 1 ) < pos_tmp ( 2 )) then ! there are nested tags with the same name do while ( pos <= len_trim ( source ) . and . tag_count > 0 ) ! search next tag with the same name pos_tmp ( 1 ) = index ( source ( pos :), trim ( open_tag )) ! relative position if ( pos_tmp ( 1 ) > 0 ) then pos_tmp ( 1 ) = pos + pos_tmp ( 1 ) - 1 ! absolute position ! check if it is open tag if ( pos_tmp ( 1 ) + len_trim ( open_tag ) <= len_trim ( source )) then if ( source ( pos_tmp ( 1 ) + len_trim ( open_tag ): pos_tmp ( 1 ) + len_trim ( open_tag )) == '>' . or . & source ( pos_tmp ( 1 ) + len_trim ( open_tag ): pos_tmp ( 1 ) + len_trim ( open_tag )) == ' ' ) then ! open tag tag_count = tag_count + 1 ! update tags counter pos = pos_tmp ( 1 ) + len_trim ( open_tag ) ! update position after tag cycle endif endif endif ! search next end tag pos_tmp ( 1 ) = index ( source ( pos :), trim ( end_tag )) ! relative position if ( pos_tmp ( 1 ) > 0 ) then pos_tmp ( 1 ) = pos + pos_tmp ( 1 ) - 1 ! absolute position tag_count = tag_count - 1 ! update tags counter if ( tag_count == 0 ) then ! found matching end tag end_pos = pos_tmp ( 1 ) return endif pos = pos_tmp ( 1 ) + len_trim ( end_tag ) ! update position after tag else exit endif enddo elseif ( pos_tmp ( 2 ) < 0 ) then ! there is a problem else end_pos = pos + pos_tmp ( 2 ) - 1 ! absolute position endif endsubroutine find_matching_end_tag pure subroutine get_tag_content ( source , tag_name , start_pos , content , end_pos ) !< Get tag content. character ( * ), intent ( in ) :: source !< Source containing tag content. character ( * ), intent ( in ) :: tag_name !< Tag name. integer , intent ( in ) :: start_pos !< Start tag content position. character (:), allocatable , intent ( out ) :: content !< Extracted tag content. integer ( I4P ), intent ( out ), optional :: end_pos !< End tag content position. character (:), allocatable :: end_tag !< End tag. integer ( I4P ) :: end_pos_ !< End tag content position, local var. integer ( I4P ) :: next_pos !< Next tag start position. character (:), allocatable :: temp_content !< Buffer. end_tag = '</' // trim ( tag_name ) // '>' content = '' call find_matching_end_tag ( source = source , start_pos = start_pos , tag_name = tag_name , end_pos = end_pos_ ) if ( present ( end_pos )) end_pos = end_pos_ if ( end_pos_ > start_pos ) then ! search first nested tag, if any next_pos = index ( source ( start_pos : end_pos_ - 1 ), '<' ) if ( next_pos > 0 ) then ! find nested tag next_pos = start_pos + next_pos - 2 temp_content = trim ( adjustl ( source ( start_pos : next_pos ))) if ( len ( temp_content ) > 0 ) content = temp_content else ! no nested tag temp_content = trim ( adjustl ( source ( start_pos : end_pos_ - 1 ))) if ( len ( temp_content ) > 0 ) content = temp_content endif endif endsubroutine get_tag_content function load_file_as_stream ( filename , delimiter_start , delimiter_end , fast_read , iostat , iomsg ) result ( stream ) !< Load file contents and store as single characters stream. character ( * ), intent ( in ) :: filename !< File name. character ( * ), optional , intent ( in ) :: delimiter_start !< Delimiter from which start the stream. character ( * ), optional , intent ( in ) :: delimiter_end !< Delimiter to which end the stream. logical , optional , intent ( in ) :: fast_read !< Flag for activating efficient reading with one single read. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: stream !< Output string containing the file data as a single stream. logical :: is_file !< Flag for inquiring the presence of the file. integer ( I4P ) :: unit !< Unit file. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< IO error message. character ( 1 ) :: c1 !< Single character. character ( len = :), allocatable :: string !< Dummy string. logical :: cstart !< Flag for stream capturing trigging. logical :: cend !< Flag for stream capturing trigging. logical :: fast !< Flag for activating efficient reading with one single read. integer ( I4P ) :: filesize !< Size of the file for fast reading. fast = . false . ; if ( present ( fast_read )) fast = fast_read ! inquire file existance inquire ( file = adjustl ( trim ( filename )), exist = is_file , iostat = iostatd , iomsg = iomsgd ) if (. not . is_file ) then if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return endif ! open file open ( newunit = unit , file = adjustl ( trim ( filename )), access = 'STREAM' , form = 'UNFORMATTED' , iostat = iostatd , iomsg = iomsgd ) if ( iostatd /= 0 ) then if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return endif ! loadg data stream = '' if ( present ( delimiter_start ). and . present ( delimiter_end )) then ! load only data inside delimiter_start and delimiter_end string = '' Main_Read_Loop : do read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 if ( c1 == delimiter_start ( 1 : 1 )) then cstart = . true . string = c1 Start_Read_Loop : do while ( len ( string ) < len ( delimiter_start )) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 string = string // c1 if (. not .( index ( string = delimiter_start , substring = string ) > 0 )) then cstart = . false . exit Start_Read_Loop endif enddo Start_Read_Loop if ( cstart ) then cend = . false . stream = string do while (. not . cend ) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 if ( c1 == delimiter_end ( 1 : 1 )) then ! maybe the end string = c1 End_Read_Loop : do while ( len ( string ) < len ( delimiter_end )) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 string = string // c1 if (. not .( index ( string = delimiter_end , substring = string ) > 0 )) then stream = stream // string exit End_Read_Loop elseif ( len ( string ) == len ( delimiter_end )) then cend = . true . stream = stream // string exit Main_Read_Loop endif enddo End_Read_Loop else stream = stream // c1 endif enddo endif endif enddo Main_Read_Loop else ! load all data if ( fast ) then ! load fast inquire ( file = adjustl ( trim ( filename )), size = filesize , iostat = iostatd , iomsg = iomsgd ) if ( iostatd == 0 ) then if ( allocated ( stream )) deallocate ( stream ) allocate ( character ( len = filesize ) :: stream ) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) stream endif else ! load slow, one character loop Read_Loop : do read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 stream = stream // c1 enddo Read_Loop endif endif 10 close ( unit ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endfunction load_file_as_stream pure subroutine parse_tag_name ( tag_str , tag_name , attributes_str , is_closing , is_self_closing ) !< Parse current tag, only name and attributes. character ( * ), intent ( in ) :: tag_str !< Tag string. character (:), allocatable , intent ( out ) :: tag_name !< Parsed tag name. character (:), allocatable , intent ( out ) :: attributes_str !< Parsed attributes list. logical , intent ( out ) :: is_closing !< Sentinel for closing tag. logical , intent ( out ) :: is_self_closing !< Sentinel for self closing tag. character (:), allocatable :: clean_tag !< Clean tag string. integer ( I4P ) :: space_pos !< Blank space position. clean_tag = trim ( adjustl ( tag_str )) if ( len ( clean_tag ) < 3 ) return ! trim < and > clean_tag = clean_tag ( 2 : len ( clean_tag ) - 1 ) is_self_closing = ( clean_tag ( len ( clean_tag ): len ( clean_tag )) == '/' ) if ( is_self_closing ) then is_closing = . false . else is_closing = ( clean_tag ( 1 : 1 ) == '/' ) endif if ( is_closing ) clean_tag = clean_tag ( 2 :) if ( is_self_closing ) clean_tag = clean_tag ( 1 : len ( clean_tag ) - 1 ) ! parse name and attributes space_pos = index ( clean_tag , ' ' ) if ( space_pos > 0 ) then tag_name = clean_tag ( 1 : space_pos - 1 ) attributes_str = clean_tag ( space_pos + 1 :) else tag_name = clean_tag endif endsubroutine parse_tag_name endmodule foxy_xml_file","tags":"","url":"sourcefile/foxy_xml_file.f90.html"},{"title":"foxy_test_create_tag.f90 – FoXy","text":"FoXy test. This file depends on sourcefile~~foxy_test_create_tag.f90~~EfferentGraph sourcefile~foxy_test_create_tag.f90 foxy_test_create_tag.f90 sourcefile~foxy.f90 foxy.f90 sourcefile~foxy_test_create_tag.f90->sourcefile~foxy.f90 sourcefile~foxy_xml_file.f90 foxy_xml_file.f90 sourcefile~foxy.f90->sourcefile~foxy_xml_file.f90 sourcefile~foxy_xml_tag.f90 foxy_xml_tag.F90 sourcefile~foxy.f90->sourcefile~foxy_xml_tag.f90 sourcefile~foxy_xml_file.f90->sourcefile~foxy_xml_tag.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< FoXy test. program foxy_test_create_tag !< FoXy test. use foxy , only : xml_tag implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_tag ) :: a_tag !< XML tag handler. logical :: test_passed ( 4 ) !< List of passed tests. test_passed = . false . ! create using xml_tag overloaded procedures print \"(A)\" , 'source' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'first' , content = 'lorem ipsum...' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ])) parsed = a_tag % stringify () test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // 'Is correct? ' , test_passed ( 1 ) print \"(A)\" , 'source' source = '<second x=\"1\" y=\"c\" z=\"2\"/>' print \"(A)\" , source print \"(A)\" , 'created' a_tag = xml_tag ( name = 'second' , attributes = reshape ([[ 'x' , '1' ], [ 'y' , 'c' ], [ 'z' , '2' ]], [ 2 , 3 ]), is_self_closing = . true .) parsed = a_tag % stringify () test_passed ( 2 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 2 ) ! create parsing a source print \"(A)\" , 'source' source = '<third x=\"1\" y=\"c\" z=\"2\"/>' print \"(A)\" , source print \"(A)\" , 'created' call a_tag % set ( name = 'third' ) call a_tag % parse ( source = source ) parsed = a_tag % stringify () test_passed ( 3 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 3 ) print \"(A)\" , 'source' source = '<fourth x=\"1\" y=\"c\" z=\"2\"></fourth>' print \"(A)\" , source print \"(A)\" , 'created' call a_tag % set ( name = 'fourth' ) call a_tag % parse ( source = source ) parsed = a_tag % stringify () test_passed ( 4 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , parsed // ' Is correct? ' , test_passed ( 4 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram foxy_test_create_tag","tags":"","url":"sourcefile/foxy_test_create_tag.f90.html"}]}